// Generated by purs version 0.15.15
var LeafF = /* #__PURE__ */ (function () {
    function LeafF(value0) {
        this.value0 = value0;
    };
    LeafF.create = function (value0) {
        return new LeafF(value0);
    };
    return LeafF;
})();
var BranchF = /* #__PURE__ */ (function () {
    function BranchF(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    BranchF.create = function (value0) {
        return function (value1) {
            return new BranchF(value0, value1);
        };
    };
    return BranchF;
})();
var Literal = /* #__PURE__ */ (function () {
    function Literal() {

    };
    Literal.value = new Literal();
    return Literal;
})();
var Operator = /* #__PURE__ */ (function () {
    function Operator() {

    };
    Operator.value = new Operator();
    return Operator;
})();
var Intermediate = /* #__PURE__ */ (function () {
    function Intermediate() {

    };
    Intermediate.value = new Intermediate();
    return Intermediate;
})();
var Result = /* #__PURE__ */ (function () {
    function Result() {

    };
    Result.value = new Result();
    return Result;
})();
var ZeroF = /* #__PURE__ */ (function () {
    function ZeroF() {

    };
    ZeroF.value = new ZeroF();
    return ZeroF;
})();
var SuccF = /* #__PURE__ */ (function () {
    function SuccF(value0) {
        this.value0 = value0;
    };
    SuccF.create = function (value0) {
        return new SuccF(value0);
    };
    return SuccF;
})();
var NilF = /* #__PURE__ */ (function () {
    function NilF() {

    };
    NilF.value = new NilF();
    return NilF;
})();
var ConsF = /* #__PURE__ */ (function () {
    function ConsF(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ConsF.create = function (value0) {
        return function (value1) {
            return new ConsF(value0, value1);
        };
    };
    return ConsF;
})();
var Fix = function (x) {
    return x;
};
var LitF = /* #__PURE__ */ (function () {
    function LitF(value0) {
        this.value0 = value0;
    };
    LitF.create = function (value0) {
        return new LitF(value0);
    };
    return LitF;
})();
var AddF = /* #__PURE__ */ (function () {
    function AddF(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    AddF.create = function (value0) {
        return function (value1) {
            return new AddF(value0, value1);
        };
    };
    return AddF;
})();
var MulF = /* #__PURE__ */ (function () {
    function MulF(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    MulF.create = function (value0) {
        return function (value1) {
            return new MulF(value0, value1);
        };
    };
    return MulF;
})();
var SubF = /* #__PURE__ */ (function () {
    function SubF(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    SubF.create = function (value0) {
        return function (value1) {
            return new SubF(value0, value1);
        };
    };
    return SubF;
})();
var zero = /* #__PURE__ */ (function () {
    return ZeroF.value;
})();
var unfix = function (v) {
    return v;
};
var succ = function (n) {
    return new SuccF(n);
};
var sub = function (a) {
    return function (b) {
        return new SubF(a, b);
    };
};
var nil = /* #__PURE__ */ (function () {
    return NilF.value;
})();
var mul = function (a) {
    return function (b) {
        return new MulF(a, b);
    };
};
var lit = function (n) {
    return new LitF(n);
};
var leaf = function (x) {
    return new LeafF(x);
};
var functorTreeF = {
    map: function (f) {
        return function (m) {
            if (m instanceof LeafF) {
                return new LeafF(m.value0);
            };
            if (m instanceof BranchF) {
                return new BranchF(f(m.value0), f(m.value1));
            };
            throw new Error("Failed pattern match at Zoo.Types (line 0, column 0 - line 0, column 0): " + [ m.constructor.name ]);
        };
    }
};
var functorNatF = {
    map: function (f) {
        return function (m) {
            if (m instanceof ZeroF) {
                return ZeroF.value;
            };
            if (m instanceof SuccF) {
                return new SuccF(f(m.value0));
            };
            throw new Error("Failed pattern match at Zoo.Types (line 0, column 0 - line 0, column 0): " + [ m.constructor.name ]);
        };
    }
};
var functorListF = {
    map: function (f) {
        return function (m) {
            if (m instanceof NilF) {
                return NilF.value;
            };
            if (m instanceof ConsF) {
                return new ConsF(m.value0, f(m.value1));
            };
            throw new Error("Failed pattern match at Zoo.Types (line 0, column 0 - line 0, column 0): " + [ m.constructor.name ]);
        };
    }
};
var functorExprF = {
    map: function (f) {
        return function (m) {
            if (m instanceof LitF) {
                return new LitF(m.value0);
            };
            if (m instanceof AddF) {
                return new AddF(f(m.value0), f(m.value1));
            };
            if (m instanceof MulF) {
                return new MulF(f(m.value0), f(m.value1));
            };
            if (m instanceof SubF) {
                return new SubF(f(m.value0), f(m.value1));
            };
            throw new Error("Failed pattern match at Zoo.Types (line 0, column 0 - line 0, column 0): " + [ m.constructor.name ]);
        };
    }
};
var eqNodeRole = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Literal && y instanceof Literal) {
                return true;
            };
            if (x instanceof Operator && y instanceof Operator) {
                return true;
            };
            if (x instanceof Intermediate && y instanceof Intermediate) {
                return true;
            };
            if (x instanceof Result && y instanceof Result) {
                return true;
            };
            return false;
        };
    }
};
var cons = function (x) {
    return function (xs) {
        return new ConsF(x, xs);
    };
};
var branch = function (l) {
    return function (r) {
        return new BranchF(l, r);
    };
};
var add = function (a) {
    return function (b) {
        return new AddF(a, b);
    };
};
export {
    Fix,
    unfix,
    LitF,
    AddF,
    MulF,
    SubF,
    lit,
    add,
    mul,
    sub,
    NilF,
    ConsF,
    nil,
    cons,
    ZeroF,
    SuccF,
    zero,
    succ,
    LeafF,
    BranchF,
    leaf,
    branch,
    Literal,
    Operator,
    Intermediate,
    Result,
    functorExprF,
    functorListF,
    functorNatF,
    functorTreeF,
    eqNodeRole
};
//# sourceMappingURL=index.js.map
