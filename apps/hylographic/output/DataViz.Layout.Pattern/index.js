// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_EuclideanRing from "../Data.EuclideanRing/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as DataViz_Layout_Pattern_Types from "../DataViz.Layout.Pattern.Types/index.js";
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordNumber);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var div1 = /* #__PURE__ */ Data_EuclideanRing.div(Data_EuclideanRing.euclideanRingInt);
var mod = /* #__PURE__ */ Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt);
var vertical = function (vp) {
    return function (n) {
        var area = DataViz_Layout_Pattern_Types.usableArea(vp);
        var centerX = area.x + area.width / 2.0;
        var step = (function () {
            var $29 = n <= 1;
            if ($29) {
                return 0.0;
            };
            return area.height / Data_Int.toNumber(n - 1 | 0);
        })();
        return Data_Array.mapWithIndex(function (i) {
            return function (v) {
                return {
                    x: centerX,
                    y: area.y + Data_Int.toNumber(i) * step
                };
            };
        })(Data_Array.replicate(n)(Data_Unit.unit));
    };
};
var radial = function (vp) {
    return function (n) {
        var area = DataViz_Layout_Pattern_Types.usableArea(vp);
        var centerX = area.x + area.width / 2.0;
        var centerY = area.y + area.height / 2.0;
        var radius = min(area.width / 2.0)(area.height / 2.0) * 0.9;
        var angleStep = (2.0 * Data_Number.pi) / Data_Int.toNumber(max(1)(n));
        return Data_Array.mapWithIndex(function (i) {
            return function (v) {
                var theta = Data_Int.toNumber(i) * angleStep - Data_Number.pi / 2.0;
                return {
                    x: centerX + radius * Data_Number.cos(theta),
                    y: centerY + radius * Data_Number.sin(theta)
                };
            };
        })(Data_Array.replicate(n)(Data_Unit.unit));
    };
};
var layeredCentered = function (vp) {
    return function (layerCounts) {
        var numLayers = Data_Array.length(layerCounts);
        var area = DataViz_Layout_Pattern_Types.usableArea(vp);
        var layerHeight = area.height / Data_Int.toNumber(max(1)(numLayers));
        var layerPositions = function (layerIdx) {
            return function (count) {
                var y = area.y + (Data_Int.toNumber(layerIdx) + 0.5) * layerHeight;
                var cellWidth = area.width / Data_Int.toNumber(max(1)(count));
                return Data_Array.mapWithIndex(function (i) {
                    return function (v) {
                        return {
                            x: area.x + (Data_Int.toNumber(i) + 0.5) * cellWidth,
                            y: y
                        };
                    };
                })(Data_Array.replicate(count)(Data_Unit.unit));
            };
        };
        return Data_Array.concat(Data_Array.mapWithIndex(layerPositions)(layerCounts));
    };
};
var layered = function (vp) {
    return function (layerCounts) {
        var numLayers = Data_Array.length(layerCounts);
        var area = DataViz_Layout_Pattern_Types.usableArea(vp);
        var layerStep = (function () {
            var $30 = numLayers <= 1;
            if ($30) {
                return 0.0;
            };
            return area.height / Data_Int.toNumber(numLayers - 1 | 0);
        })();
        var layerPositions = function (layerIdx) {
            return function (count) {
                var y = area.y + Data_Int.toNumber(layerIdx) * layerStep;
                var step = (function () {
                    var $31 = count <= 1;
                    if ($31) {
                        return 0.0;
                    };
                    return area.width / Data_Int.toNumber(count - 1 | 0);
                })();
                return Data_Array.mapWithIndex(function (i) {
                    return function (v) {
                        return {
                            x: area.x + Data_Int.toNumber(i) * step,
                            y: y
                        };
                    };
                })(Data_Array.replicate(count)(Data_Unit.unit));
            };
        };
        return Data_Array.concat(Data_Array.mapWithIndex(layerPositions)(layerCounts));
    };
};
var horizontal = function (vp) {
    return function (n) {
        var area = DataViz_Layout_Pattern_Types.usableArea(vp);
        var centerY = area.y + area.height / 2.0;
        var step = (function () {
            var $32 = n <= 1;
            if ($32) {
                return 0.0;
            };
            return area.width / Data_Int.toNumber(n - 1 | 0);
        })();
        return Data_Array.mapWithIndex(function (i) {
            return function (v) {
                return {
                    x: area.x + Data_Int.toNumber(i) * step,
                    y: centerY
                };
            };
        })(Data_Array.replicate(n)(Data_Unit.unit));
    };
};
var honeycomb = function (vp) {
    return function (n) {
        var verticalRatio = Data_Number.sqrt(3.0) / 2.0;
        var area = DataViz_Layout_Pattern_Types.usableArea(vp);
        var aspect = area.width / area.height;
        var cols = max(1)(Data_Int.ceil(Data_Number.sqrt((Data_Int.toNumber(n) * aspect) / verticalRatio)));
        var rows = max(1)(Data_Int.ceil(Data_Int.toNumber(n) / Data_Int.toNumber(cols)));
        var cellH = area.height / Data_Int.toNumber(rows);
        var offsetY = cellH / 2.0;
        var cellW = area.width / Data_Int.toNumber(cols);
        var offsetX = cellW / 2.0;
        return Data_Array.mapWithIndex(function (i) {
            return function (v) {
                var row = div1(i)(cols);
                var rowOffset = (function () {
                    var $33 = mod(row)(2) === 1;
                    if ($33) {
                        return cellW / 2.0;
                    };
                    return 0.0;
                })();
                var col = mod(i)(cols);
                return {
                    x: area.x + Data_Int.toNumber(col) * cellW + offsetX + rowOffset,
                    y: area.y + Data_Int.toNumber(row) * cellH + offsetY
                };
            };
        })(Data_Array.replicate(n)(Data_Unit.unit));
    };
};
var gridWithAspect = function (cellAspect) {
    return function (vp) {
        return function (n) {
            var area = DataViz_Layout_Pattern_Types.usableArea(vp);
            var viewAspect = area.width / area.height;
            var cols = max(1)(Data_Int.ceil(Data_Number.sqrt((Data_Int.toNumber(n) * viewAspect) / cellAspect)));
            var cellW = area.width / Data_Int.toNumber(cols);
            var offsetX = cellW / 2.0;
            var rows = max(1)(Data_Int.ceil(Data_Int.toNumber(n) / Data_Int.toNumber(cols)));
            var cellH = area.height / Data_Int.toNumber(rows);
            var offsetY = cellH / 2.0;
            return Data_Array.mapWithIndex(function (i) {
                return function (v) {
                    var row = div1(i)(cols);
                    var col = mod(i)(cols);
                    return {
                        x: area.x + Data_Int.toNumber(col) * cellW + offsetX,
                        y: area.y + Data_Int.toNumber(row) * cellH + offsetY
                    };
                };
            })(Data_Array.replicate(n)(Data_Unit.unit));
        };
    };
};
var gridExact = function (cols) {
    return function (vp) {
        return function (n) {
            var rows = max(1)(Data_Int.ceil(Data_Int.toNumber(n) / Data_Int.toNumber(max(1)(cols))));
            var area = DataViz_Layout_Pattern_Types.usableArea(vp);
            var cellH = area.height / Data_Int.toNumber(rows);
            var offsetY = cellH / 2.0;
            var actualCols = max(1)(cols);
            var cellW = area.width / Data_Int.toNumber(actualCols);
            var offsetX = cellW / 2.0;
            return Data_Array.mapWithIndex(function (i) {
                return function (v) {
                    var row = div1(i)(actualCols);
                    var col = mod(i)(actualCols);
                    return {
                        x: area.x + Data_Int.toNumber(col) * cellW + offsetX,
                        y: area.y + Data_Int.toNumber(row) * cellH + offsetY
                    };
                };
            })(Data_Array.replicate(n)(Data_Unit.unit));
        };
    };
};
var grid = function (vp) {
    return function (n) {
        var area = DataViz_Layout_Pattern_Types.usableArea(vp);
        var aspect = area.width / area.height;
        var cols = max(1)(Data_Int.ceil(Data_Number.sqrt(Data_Int.toNumber(n) * aspect)));
        var rows = max(1)(Data_Int.ceil(Data_Int.toNumber(n) / Data_Int.toNumber(cols)));
        var cellH = area.height / Data_Int.toNumber(rows);
        var offsetY = cellH / 2.0;
        var cellW = area.width / Data_Int.toNumber(cols);
        var offsetX = cellW / 2.0;
        return Data_Array.mapWithIndex(function (i) {
            return function (v) {
                var row = div1(i)(cols);
                var col = mod(i)(cols);
                return {
                    x: area.x + Data_Int.toNumber(col) * cellW + offsetX,
                    y: area.y + Data_Int.toNumber(row) * cellH + offsetY
                };
            };
        })(Data_Array.replicate(n)(Data_Unit.unit));
    };
};
var goldenAngle = /* #__PURE__ */ (function () {
    return Data_Number.pi * (3.0 - Data_Number.sqrt(5.0));
})();
var phyllotaxis = function (vp) {
    return function (n) {
        var area = DataViz_Layout_Pattern_Types.usableArea(vp);
        var centerX = area.x + area.width / 2.0;
        var centerY = area.y + area.height / 2.0;
        var maxRadius = min(area.width / 2.0)(area.height / 2.0);
        var scale = maxRadius / Data_Number.sqrt(Data_Int.toNumber(n));
        return Data_Array.mapWithIndex(function (i) {
            return function (v) {
                var theta = Data_Int.toNumber(i) * goldenAngle;
                var r = scale * Data_Number.sqrt(Data_Int.toNumber(i));
                return {
                    x: centerX + r * Data_Number.cos(theta),
                    y: centerY + r * Data_Number.sin(theta)
                };
            };
        })(Data_Array.replicate(n)(Data_Unit.unit));
    };
};
var fermat = function (divergenceAngle) {
    return function (vp) {
        return function (n) {
            var area = DataViz_Layout_Pattern_Types.usableArea(vp);
            var centerX = area.x + area.width / 2.0;
            var centerY = area.y + area.height / 2.0;
            var maxRadius = min(area.width / 2.0)(area.height / 2.0);
            var scale = maxRadius / Data_Number.sqrt(Data_Int.toNumber(n));
            return Data_Array.mapWithIndex(function (i) {
                return function (v) {
                    var theta = Data_Int.toNumber(i) * divergenceAngle;
                    var r = scale * Data_Number.sqrt(Data_Int.toNumber(i));
                    return {
                        x: centerX + r * Data_Number.cos(theta),
                        y: centerY + r * Data_Number.sin(theta)
                    };
                };
            })(Data_Array.replicate(n)(Data_Unit.unit));
        };
    };
};
var diagonal = function (vp) {
    return function (n) {
        var area = DataViz_Layout_Pattern_Types.usableArea(vp);
        var stepX = (function () {
            var $34 = n <= 1;
            if ($34) {
                return 0.0;
            };
            return area.width / Data_Int.toNumber(n - 1 | 0);
        })();
        var stepY = (function () {
            var $35 = n <= 1;
            if ($35) {
                return 0.0;
            };
            return area.height / Data_Int.toNumber(n - 1 | 0);
        })();
        return Data_Array.mapWithIndex(function (i) {
            return function (v) {
                return {
                    x: area.x + Data_Int.toNumber(i) * stepX,
                    y: area.y + Data_Int.toNumber(i) * stepY
                };
            };
        })(Data_Array.replicate(n)(Data_Unit.unit));
    };
};
var concentricRings = function (ringCount) {
    return function (vp) {
        return function (n) {
            var totalWeight = Data_Int.toNumber(div1(ringCount * (ringCount + 1 | 0) | 0)(2));
            var itemsPerRing = Data_Array.mapWithIndex(function (k) {
                return function (v) {
                    var weight = Data_Int.toNumber(k + 1 | 0) / totalWeight;
                    return max(1)(Data_Int.floor(Data_Int.toNumber(n) * weight + 0.5));
                };
            })(Data_Array.replicate(ringCount)(Data_Unit.unit));
            var area = DataViz_Layout_Pattern_Types.usableArea(vp);
            var centerX = area.x + area.width / 2.0;
            var centerY = area.y + area.height / 2.0;
            var maxRadius = min(area.width / 2.0)(area.height / 2.0) * 0.9;
            var generateRing = function (ringIdx) {
                return function (_startIdx) {
                    return function (count) {
                        var radius = (maxRadius * Data_Int.toNumber(ringIdx + 1 | 0)) / Data_Int.toNumber(ringCount);
                        var angleStep = (2.0 * Data_Number.pi) / Data_Int.toNumber(max(1)(count));
                        return Data_Array.mapWithIndex(function (i) {
                            return function (v) {
                                var theta = Data_Int.toNumber(i) * angleStep - Data_Number.pi / 2.0;
                                return {
                                    x: centerX + radius * Data_Number.cos(theta),
                                    y: centerY + radius * Data_Number.sin(theta)
                                };
                            };
                        })(Data_Array.replicate(count)(Data_Unit.unit));
                    };
                };
            };
            return Data_Array.take(n)(Data_Array.concat(Data_Array.mapWithIndex(function (ringIdx) {
                return function (count) {
                    return generateRing(ringIdx)(0)(count);
                };
            })(itemsPerRing)));
        };
    };
};
var sunburst = concentricRings;
var brick = honeycomb;
var archimedean = function (spacing) {
    return function (vp) {
        return function (n) {
            var totalAngle = Data_Int.toNumber(n) * spacing;
            var area = DataViz_Layout_Pattern_Types.usableArea(vp);
            var centerX = area.x + area.width / 2.0;
            var centerY = area.y + area.height / 2.0;
            var maxRadius = min(area.width / 2.0)(area.height / 2.0);
            var radiusPerRadian = maxRadius / totalAngle;
            return Data_Array.mapWithIndex(function (i) {
                return function (v) {
                    var theta = Data_Int.toNumber(i) * spacing;
                    var r = theta * radiusPerRadian;
                    return {
                        x: centerX + r * Data_Number.cos(theta),
                        y: centerY + r * Data_Number.sin(theta)
                    };
                };
            })(Data_Array.replicate(n)(Data_Unit.unit));
        };
    };
};
var along = function (start) {
    return function (end) {
        return function (n) {
            var step = (function () {
                var $36 = n <= 1;
                if ($36) {
                    return 0.0;
                };
                return 1.0 / Data_Int.toNumber(n - 1 | 0);
            })();
            var dy = end.y - start.y;
            var dx = end.x - start.x;
            return Data_Array.mapWithIndex(function (i) {
                return function (v) {
                    var t = Data_Int.toNumber(i) * step;
                    return {
                        x: start.x + t * dx,
                        y: start.y + t * dy
                    };
                };
            })(Data_Array.replicate(n)(Data_Unit.unit));
        };
    };
};
export {
    grid,
    gridWithAspect,
    gridExact,
    honeycomb,
    brick,
    phyllotaxis,
    archimedean,
    fermat,
    radial,
    concentricRings,
    sunburst,
    horizontal,
    vertical,
    diagonal,
    along,
    layered,
    layeredCentered
};
export {
    noPadding,
    padding,
    uniformPadding,
    usableArea,
    viewport,
    viewportWithPadding
} from "../DataViz.Layout.Pattern.Types/index.js";
//# sourceMappingURL=index.js.map
