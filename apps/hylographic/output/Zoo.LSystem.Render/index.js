// Generated by purs version 0.15.15
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Monoid from "../Data.Monoid/index.js";
import * as Data_Number from "../Data.Number/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Zoo_LSystem_Types from "../Zoo.LSystem.Types/index.js";
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showNumber);
var intercalate = /* #__PURE__ */ Data_Array.intercalate(Data_Monoid.monoidString);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_Foldable.foldableArray);
var min = /* #__PURE__ */ Data_Ord.min(Data_Ord.ordInt);
var max = /* #__PURE__ */ Data_Ord.max(Data_Ord.ordInt);
var widthForDepth = function (config) {
    return function (d) {
        return config.strokeWidth * Data_Number.pow(config.widthScale)(Data_Int.toNumber(d));
    };
};
var segmentToPath = function (s) {
    return "M " + (show(s.x1) + (" " + (show(s.y1) + (" " + ("L " + (show(s.x2) + (" " + show(s.y2))))))));
};
var segmentsToPath = function (segments) {
    return intercalate(" ")(map(segmentToPath)(segments));
};
var newSegmentsToPath = function (segments) {
    var pathData = segmentsToPath(segments);
    return "<path d=\"" + (pathData + ("\" " + ("stroke=\"#2d5a27\" " + ("stroke-width=\"1.5\" " + ("fill=\"none\" " + "stroke-linecap=\"round\"/>")))));
};
var estimatePathLength = /* #__PURE__ */ (function () {
    var segmentLength = function (s) {
        var dy = s.y2 - s.y1;
        var dx = s.x2 - s.x1;
        return Data_Number.sqrt(dx * dx + dy * dy);
    };
    return foldl(function (acc) {
        return function (s) {
            return acc + segmentLength(s);
        };
    })(0.0);
})();
var depthColors = [ "#2d5a27", "#3d7a37", "#4d9a47", "#5dba57", "#6dda67", "#7dfa77", "#8dff87", "#9dff97" ];
var defaultAttrs = {
    stroke: "#2d5a27",
    strokeWidth: 1.5,
    fill: "none",
    strokeLinecap: "round"
};
var colorForDepth = function (d) {
    var idx = min(d)(Data_Array.length(depthColors) - 1 | 0);
    return Data_Maybe.fromMaybe("#2d5a27")(Data_Array.index(depthColors)(idx));
};
var depthPath = function (config) {
    return function (depth) {
        return function (segments) {
            var $12 = Data_Array["null"](segments);
            if ($12) {
                return "";
            };
            var width = widthForDepth(config)(depth);
            var pathData = segmentsToPath(segments);
            var color = colorForDepth(depth);
            return "  <path d=\"" + (pathData + ("\" " + ("stroke=\"" + (color + ("\" " + ("stroke-width=\"" + (show(width) + ("\" " + ("fill=\"none\" " + "stroke-linecap=\"round\"/>")))))))));
        };
    };
};
var calculateBounds = /* #__PURE__ */ foldl(Zoo_LSystem_Types.expandBounds)(Zoo_LSystem_Types.emptyBounds);
var boundsToViewBox = function (b) {
    return function (padding) {
        var y = b.minY - padding;
        var x = b.minX - padding;
        var w = (b.maxX - b.minX) + 2.0 * padding;
        var h = (b.maxY - b.minY) + 2.0 * padding;
        return show(x) + (" " + (show(y) + (" " + (show(w) + (" " + show(h))))));
    };
};
var segmentsToAnimatedSVG = function (_config) {
    return function (durationSec) {
        return function (segments) {
            var pathLength = estimatePathLength(segments);
            var pathData = segmentsToPath(segments);
            var bounds = calculateBounds(segments);
            var viewBox = boundsToViewBox(bounds)(20.0);
            return "<svg xmlns=\"http://www.w3.org/2000/svg\" " + ("viewBox=\"" + (viewBox + ("\" " + ("style=\"width: 100%; height: 100%;\">\x0a" + ("  <style>\x0a" + ("    @keyframes draw {\x0a" + ("      to { stroke-dashoffset: 0; }\x0a" + ("    }\x0a" + ("    .animated-path {\x0a" + ("      stroke-dasharray: " + (show(pathLength) + (";\x0a" + ("      stroke-dashoffset: " + (show(pathLength) + (";\x0a" + ("      animation: draw " + (show(durationSec) + ("s linear forwards;\x0a" + ("    }\x0a" + ("  </style>\x0a" + ("  <path class=\"animated-path\" d=\"" + (pathData + ("\" " + ("stroke=\"#2d5a27\" " + ("stroke-width=\"1.5\" " + ("fill=\"none\" " + ("stroke-linecap=\"round\"/>\x0a" + "</svg>")))))))))))))))))))))))))));
        };
    };
};
var segmentsToColoredSVG = function (config) {
    return function (segments) {
        var maxDepth = foldl(function (m) {
            return function (s) {
                return max(m)(s.depth);
            };
        })(0)(segments);
        var depthGroups = map(function (d) {
            return Data_Array.filter(function (s) {
                return s.depth === d;
            })(segments);
        })(Data_Array.range(0)(maxDepth));
        var paths = Data_Array.mapWithIndex(depthPath(config))(depthGroups);
        var bounds = calculateBounds(segments);
        var viewBox = boundsToViewBox(bounds)(20.0);
        return "<svg xmlns=\"http://www.w3.org/2000/svg\" " + ("viewBox=\"" + (viewBox + ("\" " + ("style=\"width: 100%; height: 100%;\">\x0a" + (intercalate("\x0a")(paths) + "\x0a</svg>")))));
    };
};
var segmentsToSVG = function (_config) {
    return function (segments) {
        var pathData = segmentsToPath(segments);
        var bounds = calculateBounds(segments);
        var viewBox = boundsToViewBox(bounds)(20.0);
        return "<svg xmlns=\"http://www.w3.org/2000/svg\" " + ("viewBox=\"" + (viewBox + ("\" " + ("style=\"width: 100%; height: 100%;\">\x0a" + ("  <path d=\"" + (pathData + ("\" " + ("stroke=\"" + (defaultAttrs.stroke + ("\" " + ("stroke-width=\"" + (show(defaultAttrs.strokeWidth) + ("\" " + ("fill=\"" + (defaultAttrs.fill + ("\" " + ("stroke-linecap=\"" + (defaultAttrs.strokeLinecap + ("\"/>\x0a" + "</svg>")))))))))))))))))));
    };
};
export {
    segmentsToPath,
    segmentToPath,
    defaultAttrs,
    segmentsToSVG,
    depthColors,
    colorForDepth,
    widthForDepth,
    segmentsToColoredSVG,
    depthPath,
    calculateBounds,
    boundsToViewBox,
    segmentsToAnimatedSVG,
    estimatePathLength,
    newSegmentsToPath
};
//# sourceMappingURL=index.js.map
