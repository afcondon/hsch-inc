# Worklog: 2026-01-19

## Session 1: Phase 6 - Native Zoom Implementation

### Accomplished

1. **Created native zoom module** (`PSD3.Interaction.Zoom`)
   - Vendored D3-zoom transform math (ISC licensed, ~200 lines)
   - ZoomTransform class with scale, translate, apply, invert methods
   - Native event handlers: wheel, pointer, Safari gesture events

2. **Implemented ZoomHandle API**
   - `getTransform` / `setTransform` - Read/write transform state
   - `resetZoom` - Reset to identity
   - `zoomTo` - Zoom to scale at specific point
   - `zoomBy` - Zoom by factor at center
   - `destroy` - Cleanup event listeners

3. **Integrated with Behavior system**
   - `applyBehaviorToElement` now uses `NativeZoom.attachZoomNative`
   - `Zoom` behavior in TreeAPI automatically uses native implementation
   - Drop-in compatible with existing `attachZoom_` usage

4. **Updated exports**
   - Added `PSD3.Interaction.Zoom` to PSD3.purs re-exports
   - Types: `ZoomTransform`, `ZoomConfig`, `ZoomHandle`
   - Functions: `attachNativeZoom`, `attachZoomNative`, `attachZoomWithTransform`, `attachZoomWithCallback`

### Files Created/Modified

**Created:**
- `src/PSD3/Interaction/Zoom.purs` - PureScript API
- `src/PSD3/Interaction/Zoom.js` - Vendored math + native events

**Modified:**
- `src/PSD3/Internal/Selection/Operations.purs` - Import NativeZoom, update applyBehaviorToElement
- `src/PSD3.purs` - Export Zoom module
- `docs/kb/reference/d3-dependency-audit.md` - Mark Phase 6 complete
- `~/.claude/plans/twinkling-singing-hartmanis.md` - Update plan status

### Key Design Decisions

1. **Vendor vs wrap**: Chose to vendor D3-zoom math directly rather than wrapping a JS library
   - ISC license permits this
   - Gives us control over the code
   - No runtime dependency on d3-zoom package

2. **ZoomHandle pattern**: Return a handle with methods rather than just attaching behavior
   - Enables programmatic zoom control (zoomTo, resetZoom)
   - Provides cleanup via destroy()
   - More flexible than D3's approach

3. **Event coverage**: Support wheel + pointer + gesture
   - Wheel: Standard mouse wheel zoom
   - Pointer: Pan via drag (setPointerCapture for smooth dragging)
   - Gesture: Safari trackpad pinch-to-zoom

### Testing Needed

- [ ] TreeBuilder2/3 zoom behavior
- [ ] Trackpad pinch zoom (Safari)
- [ ] Scale extent constraints
- [ ] Translate extent (pan limits)
- [ ] Transform persistence across re-renders

### D3 Dependency Status After Phase 6

**Keeping (intentional):**
- d3-force (physics)
- d3-scale (scales)
- d3-scale-chromatic (colors)
- d3-interpolate (color interpolation)

**Eliminated:**
- d3-zoom ✅ (now native)
- d3-drag (native pointer module ready)
- d3-transition (pure PS transition system ready)
- d3-brush (native pattern demonstrated)

**Remaining:**
- d3-shape (arc only) - Phase 7
- d3-selection - Phase 8 (blocked by above)

### Next Steps

1. **Testing**: Verify native zoom in TreeBuilder showcases
2. **Phase 7**: Create pure PureScript arc generator for pie/donut charts
3. **Phase 8**: Final d3-selection cleanup once all behaviors are native

---

## Session 2: Brainstorming - Isometric Data Viz Showcase

### The Spark

"What if... data viz, purescript-isometric meets PSD3 meets Monument Valley?"

### Key Resources

- **purescript-isometric**: Isometric rendering library by sharkdp
  - Already supports impossible geometry (Penrose triangle with rotation)
  - Wave demo: 2D grid with height-mapped blocks, slider-animated
  - GitHub: https://github.com/sharkdp/purescript-isometric

- **cube-composer**: Puzzle game by same author using purescript-isometric
  - Compose functional operations (map, filter) to transform colored cubes
  - Teaches FP through spatial puzzle
  - GitHub: https://github.com/sharkdp/cube-composer

### Concept Directions

#### Direction A: Geographic + Stacked Columns (Serious)

Fill portfolio gap (no geo examples yet). Isometric map with tower columns:

- **Transit stations**: City map, towers = ridership, stacks = hourly breakdown or line
  - Animate through day → city "breathes" (suburban→CBD→reverse)
  - Tokyo Metro, NYC MTA, TfL all publish data

- **Power grid**: Substations on map, height = throughput, stack = energy source mix
  - Watch solar climb with sun, gas ramp for peak
  - Connects to existing Hypo-Punter/Grid Explorer work

- **Ports/shipping**: Global ports, height = TEUs, stack = trade partner or cargo type

- **Simple prototype**: Country outline + population towers (stacked by age? urban/rural?)

#### Direction B: Whimsical Impossible Geometry (Monument Valley Energy)

Lean into the aesthetic. Data mapped onto impossible structures:

- **Penrose triangle with data**: Each block sized/colored by value
  - Rotation slider = "reveal the trick"
  - At one angle: beautiful illusion
  - At another: underlying data structure exposed

- **Impossible waterfalls**: Sankey diagrams that flow uphill visually
  - Could represent circular economies, feedback loops, or "impossible" budget math

- **Data that justifies impossibility**:
  - Circular dependencies → Penrose triangle
  - Feedback loops → impossible waterfall
  - Git history with weird merges → Escher stairs

#### Direction C: AST as Architecture

Map PSD3's declarative philosophy to physical space:

1. **AST as literal building**
   - Each node = block
   - Nesting depth = height
   - Branching = horizontal spread
   - Hover block → see code fragment
   - Different interpreters = different colorings of same structure

2. **Interpretation as viewpoint**
   - Same AST, rotate view
   - 0°: DOM structure
   - 120°: performance characteristics
   - 240°: type flow
   - "Impossible" insight: same structure looks different from each angle

3. **Finally Tagless as Penrose**
   - Type class = the "impossible" shape
   - Each instance = viewing angle where it resolves
   - Rotate between interpreters, watch building reassemble

#### Direction D: Puzzle Game - "AST Architect"

Invert cube-composer:

- Given a *target visualization* (beautiful isometric scene)
- Write the DSL that produces it
- Each operation adds/removes/transforms blocks
- Puzzle: find minimal/elegant expression
- Teaching: declarative thinking, code↔visual relationship

Extensions with Monument Valley flavor:
- Puzzle space itself is impossible architecture
- Transformations *create* the path (your `filter` removes blocking cubes)
- Goal isn't "match pattern" but "navigate to exit"

#### Direction E: Animated Data Surface (Simplest Start)

Just the wave demo, but with real data:

- Replace `sin(x,y)` with actual dataset
- x,y = spatial or categorical coordinates
- height = value
- Slider scrubs through time or adjusts parameters
- Demonstrates nested data join in isometric

### Synthesis Thoughts

The most "PSD3-aligned" concept might combine:
- Real data grounding (Direction A or E)
- The AST/interpreter insight (Direction C)
- Interactive exploration with a puzzle/discovery element (Direction D)

One vision: **"Watch your data transformation"**
- Input: grid of real data
- Compose transformations visually (cube-composer style)
- Isometric view shows data morphing
- The transformations ARE the AST
- Side panel shows generated code

### Anagram Candidates

Need a codename. Working material:
- "Isometric Data" = ?
- "Monument Valley" = ?
- "Penrose Cubes" = ?
- "Block Composer" = ?

(To be figured out once direction solidifies)

### Parking Lot

- What's the current state of purescript-isometric? Compatible with our spago/registry?
- Does sharkdp's code have a license we can build on?
- Could this tie into shaped-steer's spreadsheet vision? (Cells as blocks?)
- The honeycomb showcase was mentioned - what's its current state?

### Next Steps

1. Sleep on it
2. Look at purescript-isometric codebase, assess compatibility
3. Pick a direction (or hybrid)
4. Prototype: simplest possible isometric data viz with real data

---

## Session 3: Brainstorming - Three.js Orrery Showcase

### The Spark

"How feasible is a Three.js orrery now that we control nearly everything in PureScript?"

Plus: "It would be sexy" and "bounce people out of thinking automatically of charts."

### Reference

CodePen by VoXelo: https://codepen.io/VoXelo/pen/myeOpxr
- Three.js + GLSL shaders
- Glowing sun with bloom effect
- Visible orbital rings (warm amber "Inferno" palette)
- OrbitControls for multi-axis drag
- UI: time controls, theme selector, "Activate Resonance"
- Sci-fi aesthetic (Orbitron font, status panel)

### Why This Works for PSD3

**Pattern alignment:**
- Same as D3 approach: PureScript owns state/description, JS library renders
- Planets are just data: `{ name, distance, period, radius, color }`
- Scene description is declarative
- Three.js handles WebGL complexity

**Portfolio impact:**
- Visitor sees: force graphs, Sankey, trees... then an *orrery*
- Immediate signal: "these people aren't just wrapping D3"
- Beautiful things stick in memory

**Minimal FFI surface:**
```
createScene, createCamera, createRenderer
createSphere, createTorus (orbital rings)
setPosition, animate
addBloom (post-processing)
OrbitControls (from Three.js examples)
```

### The Data-Driven Angle: Procedural Solar Systems

Instead of copying the CodePen (static solar system), make it generative:

**"New System" button → generate random solar system → render it**

This demonstrates the core PSD3 principle: visualization as function of data.

**Generation options:**

*Plausible mode (real physics):*
- Orbital resonances (stable spacing)
- Habitable zone highlighting
- Titius-Bode-ish logarithmic spacing
- Planet types by distance (rocky inner, gas giants outer)
- Randomized but physically plausible

*Fantasy mode:*
- Binary/trinary stars
- Retrograde orbits
- Wild color palettes
- Ring systems, asteroid belts
- "Impossible" configurations

**Data structure:**
```purescript
type Star = { radius :: Number, temperature :: Number, color :: Color }

type Planet =
  { name :: String
  , distance :: Number      -- AU from star
  , period :: Number        -- orbital period (years)
  , radius :: Number        -- visual size
  , type :: PlanetType      -- Rocky | Gas | Ice
  , color :: Color
  , moons :: Array Moon     -- stretch goal
  }

type SolarSystem = { star :: Star, planets :: Array Planet }

generateSystem :: Seed -> SolarSystem
```

**Interactions:**
- "New System" → fresh procedural generation
- Seed display (share/recreate interesting systems)
- Time slider (speed up orbits)
- Click planet → show stats popup
- Toggle: realistic distances vs. visible spacing

### Scope Tiers

**Tier 1 - Weekend spike:**
- Sun + 4-6 planets as spheres
- Circular orbits, correct relative periods
- OrbitControls
- Time speed control
- "New System" button with basic randomization

**Tier 2 - Polished demo:**
- Glow/bloom on sun
- Orbital path visualization
- Planet textures or procedural colors
- Habitable zone indicator
- Seed sharing

**Tier 3 - Feature creep (resist):**
- Moons
- Rings (Saturn-style)
- Asteroid belts
- Binary stars
- Elliptical orbits
- Axial tilt

### Technical Notes

- Three.js OrbitControls handles camera interaction out of the box
- Bloom is a post-processing effect (EffectComposer)
- Could skip GLSL entirely for MVP (use built-in materials)
- Animation loop: requestAnimationFrame, update planet positions based on time

### Anagram Candidates

"Solar System" = ?
"Orrery" = ?
"Procedural Planets" = ?

(Short words are hard to anagram)

### Parking Lot

- Existing purescript-three bindings? (Probably ancient, may need fresh FFI)
- License for Three.js? (MIT - fine)
- Could this eventually tie into the music/Tidal work? (Orbital periods as rhythms?)
- What about exoplanet data? (Real discovered systems as presets?)

### Relationship to Isometric Ideas

These are **distinct projects** with different goals:

| Aspect | Isometric Showcase | Orrery |
|--------|-------------------|--------|
| Goal | New viz paradigm | Portfolio expansion |
| Tech | purescript-isometric (SVG/Canvas) | Three.js (WebGL) |
| Complexity | Medium-High (new concepts) | Low-Medium (solved problem) |
| Data viz angle | Central | Justified via procedural generation |
| "Wow" factor | Intellectual | Visual |

Both worth doing. Orrery is probably faster to ship.

---

## Session 4: Brainstorming - Probability Monad Visualization

### The Spark

"Monads can be other things too - probability distributions is one thing they can be. Seems graphable."

Prompted by the "Probabilistic programming" section in `docs/llm-era-programmer-toolkit.md`:
> "Bayesian inference as a programming paradigm... essentially functional programming for uncertainty."

### The Core Insight

The probability monad isn't about sequencing - it's about composing uncertainty:

```purescript
pure :: a -> Dist a                        -- point mass (certainty)
bind :: Dist a -> (a -> Dist b) -> Dist b  -- marginalization!
```

When you `bind` two distributions, you compute the joint and marginalize. Same abstraction as IO/Maybe/etc., completely different semantics. **Visualization can make this visceral.**

### Why This Is Graphable

1. **Distributions as shapes**
   - Histograms, density curves, CDFs
   - Compose distributions → watch output shape change
   - Interactive parameter tweaking

2. **Bayesian updating**
   - Prior → Evidence → Posterior (animated)
   - Classic counterintuitive examples (medical tests, Monty Hall)
   - See *why* intuition fails

3. **Probabilistic program traces**
   - Execution branches weighted by probability
   - Conditioning prunes branches
   - Tree or force graph with weighted edges

4. **Sampling visualization**
   - MCMC chain exploring state space
   - Rejection sampling accept/reject dots
   - Distribution emerges from samples

5. **Causal DAGs**
   - Bayesian networks ARE graphs
   - PSD3 already does force-directed layouts
   - Show intervention effects ("do" operator)

### The Pedagogical Angle

"Monads are burritos" hasn't worked. But:

- Show the probability monad *visually*
- *See* that bind is marginalization
- *See* that composing uncertainty differs from composing effects
- Same Monad typeclass, different semantics, made tangible

This could actually teach something hard, not just look pretty.

### Demo Concepts

| Demo | Teaches | Visualization |
|------|---------|---------------|
| **Distribution Composer** | Compound distributions | Linked density plots that update as you compose |
| **Bayes Playground** | Bayesian updating | Prior/posterior bars, animated transformation |
| **Probabilistic Traces** | Program execution semantics | Weighted tree (probability = edge thickness or opacity) |
| **MCMC Explorer** | Sampling algorithms | Scatter plot with density emerging over time |
| **Causal Inference** | DAGs + interventions | Node-link diagram with probability flow |

### Technical Approach

**Minimal Dist monad:**
```purescript
newtype Dist a = Dist (Array { value :: a, prob :: Number })

instance Functor Dist where ...
instance Apply Dist where ...
instance Applicative Dist where ...
instance Bind Dist where ...
instance Monad Dist where ...

-- Key operations
uniform :: Array a -> Dist a
weighted :: Array (Tuple a Number) -> Dist a
bernoulli :: Number -> Dist Boolean
normal :: Number -> Number -> Dist Number  -- needs sampling

condition :: (a -> Boolean) -> Dist a -> Dist a  -- Bayes!
sample :: Dist a -> Effect a
```

**Visualization layer:**
- `Dist a` → histogram/density (for small discrete, or sampled continuous)
- Composition shown as data flow diagram
- Each intermediate `Dist` rendered

### Connection to Existing PSD3

- **Force graphs** → Bayesian network structure
- **Tree layout** → Decision trees, inference traces
- **Sankey** → Probability flow through a system
- **Animation** → MCMC chains, Bayesian updating

### Scope Tiers

**Tier 1 - Concept demo:**
- Discrete distributions only (Array-based)
- Simple composition: coin flips, dice
- Bar chart visualization
- Show bind = marginalization

**Tier 2 - Bayes Playground:**
- Classic problems with sliders
- Prior/likelihood/posterior linked views
- "Reveal" button showing the math

**Tier 3 - Full PPL visualization:**
- Continuous distributions (sampling-based)
- MCMC visualization
- Causal inference
- Probabilistic program debugger

### Anagram Candidates

"Probability Monad" = ?
"Bayesian" = ?
"Uncertain" = ?

### Parking Lot

- Existing PureScript probability libraries? (`purescript-distributions`?)
- How to handle continuous distributions? (Sample-based representation)
- Could this tie into the Gen.jl / WebPPL world?
- Educational market? (Stats courses, Bayesian thinking)

### Relationship to Other Ideas

| Aspect | Isometric | Orrery | Probability |
|--------|-----------|--------|-------------|
| Goal | New paradigm | Portfolio wow | Pedagogy |
| Audience | Data viz people | General | FP learners, stats people |
| PSD3 showcase | Layout algorithms | 3D capability | Monad semantics |
| Novelty | High | Medium | High |
| Difficulty | Medium-High | Low-Medium | Medium |

This is the most *intellectually ambitious* of the ideas - it's trying to teach, not just impress.

---

## Session 5: Brainstorming - Text as Visualization (Code Layers)

### The Spark

"Syntax highlighting is only one of MANY things your code could be telling you."

Plus: "I like the idea of showing that viz could be 100% textual" - as counterpoint to pretty demos like orrery.

### The Core Insight

Syntax highlighting is just one data→visual encoding. Code has many other "layers" of information that could be visualized using the same medium (text) with different visual encodings:

| Layer | What it reveals | Encoding |
|-------|-----------------|----------|
| **Syntax** | Language grammar | Foreground color (the default) |
| **Git blame** | Who wrote each line | Background color, margin |
| **Git heat** | Change frequency | Color intensity |
| **Coverage** | Test coverage | Background (green/red/grey) |
| **Hot paths** | Performance profile | Intensity, font weight |
| **Reachability** | Dead code | Opacity (fade unreachable) |
| **Complexity** | Cyclomatic complexity | Background gradient |
| **Age** | When written | Sepia↔fresh spectrum |
| **Dependencies** | Data/control flow | Highlight on hover |
| **Types** | Inferred types | Inline annotations |
| **Security** | Tainted data flow | Warning colors |

### Visual Channels Available in Text

- Foreground color
- Background color
- Font weight (bold)
- Font style (italic)
- Opacity
- Underline / strikethrough
- Margin annotations (gutter)
- Inline annotations (like type hints)
- Line height (compress boring parts?)
- Letter spacing

### The Effect System Layer (Special Case)

"What would it look like to see effect systems in Haskell/PureScript code?"

This is a killer specific application. Visualize:

- **Pure vs effectful** regions
- **Monad transformer stacks** - see layers accumulate
- **Effect row contents** (PureScript) - what's in the row at each point
- **Where effects are introduced** vs. just propagated
- **State monad scope** - where state is threaded

**Example visualization:**
```
calculateTotal items =        -- [pure]          ░░░░░░░░
  let subtotal = sum items    -- [pure]          ░░░░░░░░
  in do
    tax <- getTaxRate         -- [Reader]        ▒▒▒▒▒▒▒▒
    log "calculating"         -- [Reader,Console]▓▓▓▓▓▓▓▓
    pure (subtotal * tax)     -- [Reader,Console]▓▓▓▓▓▓▓▓
```

You'd literally see the effect context expand/contract through the code.

**For PureScript row effects:**
- Each expression shows its effect row
- Visual diff between required effects and ambient effects
- See where `liftEffect` bridges contexts

**For monad transformers:**
- Color-code each transformer layer
- See the stack at each point
- Visualize lift operations

### The Demo Concept

**"Code Layers" or "X-Ray Code":**

1. Paste/load source code
2. Toggle between visualization layers
3. Same text, different revelations
4. Optional: blend layers (syntax + coverage)
5. Hover for details

**The statement it makes:**
- After showing orrery: "Viz can be gorgeous"
- Then show this: "...or it can be your actual code, revealing what you couldn't see"
- Both are visualization

### Connection to Existing Work

- **Corrode Expel** (Code Explorer) - already does code analysis
- **psd3-selection** - DOM manipulation for the rendering
- **Tree-sitter** mentioned in the toolkit doc - modern code parsing

### Technical Approach

**Parsing:**
- Tree-sitter for syntax (multi-language)
- Or: PureScript/Haskell specific parser for effect analysis
- Git integration for blame/heat

**Rendering:**
- Could be pure DOM (spans with classes)
- psd3-selection for dynamic updates
- CSS custom properties for theming layers

**Effect analysis (the hard part):**
- Would need type information
- For PS: could parse compiler output
- Or: build a simple effect inference for demo purposes
- Start with explicit type annotations, not inference

### Scope Tiers

**Tier 1 - Basic layers:**
- Syntax highlighting (baseline)
- Git blame (from git)
- Line age (from git)
- Manual annotation layer (user marks regions)

**Tier 2 - Analysis layers:**
- Test coverage overlay
- Complexity metrics
- Dead code (via static analysis)

**Tier 3 - Effect visualization:**
- Parse type signatures for effect info
- Show effect regions
- Monad transformer visualization
- This is the intellectually meaty part

### Anagram Candidates

"Code Layers" = ?
"Text Visualization" = ?
"Effect Regions" = ?

### Parking Lot

- How to get type/effect information? (Compiler API? IDE protocol?)
- Tree-sitter PureScript grammar exists?
- Could this become a VS Code extension? (Connects to Corrode Expel's extension)
- Performance data source? (Would need profiler integration)

### Relationship to Other Ideas

| Aspect | Isometric | Orrery | Probability | Text Layers |
|--------|-----------|--------|-------------|-------------|
| Goal | New paradigm | Visual wow | Pedagogy | Practical tool |
| Pretty? | Yes | Very | Moderate | Not the point |
| Audience | Viz people | General | FP/stats | Developers |
| Novelty | High | Medium | High | Medium-High |
| Utility | Exploratory | Low | Educational | Daily use |

This is the most *practical* of the ideas - something developers could actually use every day.

### Specific Application: PSD3 Self-Visualization

**Dogfood the concept on PSD3 itself:**

Take an existing demo (Sankey, force graph) and show its own code with layers:

| Layer | What it shows | Color |
|-------|--------------|-------|
| AST construction | Declarative description | Blue |
| Interpreter | Finally tagless instances | Green |
| Effect boundaries | Where IO/DOM happens | Orange |
| Pure computation | Layout math, algorithms | Grey/neutral |

**The demo:**
- Left panel: visualization running
- Right panel: its source code with layer toggles
- "This is what you're looking at. This is how it's built."

**What it teaches:**
- "Declarative over imperative" made visible
- AST is *this*, interpreter is *that*
- Effects confined to specific regions
- Bulk of logic is pure

This is the perfect anchor demo for Text Layers - self-referential, educational, and shows off the architecture.

### Meta-Note: Crossovers

Several ideas could combine:
- **Probability + Isometric**: Distribution as block heights
- **Probability + Text**: Visualize probabilistic program traces in code
- **Effect + Text**: See where uncertainty/probability effects live in code
- **Isometric + Code**: 3D code city (complexity = building height) - classic but could be done well

---

## Brainstorm Summary: Design Philosophy for New Demos

### Not Apps, Libraries + Showcases

These ideas should follow the **psd3-music pattern**:
- Tiny library
- Thin FFI
- Simple one-screen showcase
- Demonstrates an "open road" for those who want to take it further

**Not** building more "app-like" demos with backends, databases, multiple services. The existing showcases (Hypo-Punter, Corrode Expel, Tilted Radio, Arid Keystone) cover that territory.

### The Portfolio Now

| Type | Examples | Purpose |
|------|----------|---------|
| **Full showcases** | Corrode Expel, Hypo-Punter, Tilted Radio | Demonstrate full-stack capability |
| **Libraries** | psd3-simulation, psd3-layout, psd3-selection | Core reusable code |
| **Thin demos** | psd3-music, astar-demo | "Open road" demonstrations |

### What These New Ideas Would Be

| Idea | Type | Scope |
|------|------|-------|
| **Isometric** | Thin library + demo | `psd3-isometric` wrapping purescript-isometric + one showcase |
| **Orrery** | Thin library + demo | `psd3-three` (minimal FFI) + procedural solar system |
| **Probability** | Tiny library + demo | `Dist` monad + visualization of composition |
| **Text Layers** | Demo only? | Uses existing psd3-selection, maybe standalone |

### Success Criteria

A new demo succeeds if:
1. Fits on one screen
2. Can be understood in under a minute
3. Makes someone think "oh, I could do X with this"
4. Doesn't require a backend or complex setup
5. Code is readable enough to learn from

### The Ideas Ranked by Likely Effort

| Idea | Effort | Payoff | Start here? |
|------|--------|--------|-------------|
| **Orrery** | Low | High (visual wow) | Good first spike |
| **Probability** | Medium | High (pedagogical) | After orrery |
| **Text Layers** | Medium | Medium-High (practical) | Could prototype quickly |
| **Isometric** | Medium-High | High (novel) | Needs purescript-isometric assessment |

### Next Actions

1. Sleep on it
2. Check purescript-isometric compatibility with current registry
3. Spike the orrery (fastest to "wow")
4. Revisit probability and text layers with fresh eyes

---

## Session 6: Brainstorming - ISOTYPE Tribute

### The Spark

"Tribute to history as much as for practical purposes" - recreate a classic ISOTYPE example.

### What is ISOTYPE?

**International System Of TYpographic Picture Education** - developed by Otto Neurath and Gerd Arntz in Vienna, 1920s-30s.

Key principles:
- **Pictographic units** - each symbol represents a quantity (e.g., one figure = 1000 people)
- **Repetition over scaling** - more symbols, not bigger symbols
- **Simplified silhouettes** - Arntz's iconic pictograms
- **Democratic legibility** - designed for working-class audiences, pre-literate accessibility

This is the grandfather of modern infographics. Every "row of stick figures" chart descends from this.

### Classic Examples to Consider

| Work | Subject | Why it's iconic |
|------|---------|-----------------|
| "Only An Ocean Between" (1943) | US vs Europe comparison | Neurath's American work |
| "Modern Man in the Making" (1939) | Industrial society | Comprehensive atlas |
| Gerd Arntz pictogram sets | Universal symbols | The visual vocabulary |
| Population pyramids | Demographics | Classic ISOTYPE application |
| Industrial output comparisons | Economics | Factories, workers, production |

### Why This Fits PSD3

- **Unit-based visualization** - different philosophy from continuous scales
- **SVG symbols** - psd3-selection handles this well
- **Data-driven repetition** - classic data join: `data.flatMap(d => repeat(d.count, symbol))`
- **Historical anchor** - shows awareness of viz history, not just D3 defaults

### Technical Approach

```purescript
type IsotypeRow =
  { label :: String
  , count :: Int
  , symbol :: Symbol  -- SVG path or reference
  }

-- Each symbol instance is a data point
renderIsotype :: Array IsotypeRow -> Selection -> Effect Unit
```

Could create a small symbol library (person, factory, ship, house, etc.) in Arntz style.

### Demo Concept

**"ISOTYPE Redux"** - Pick one classic chart and faithfully recreate it:
- Original data (historical)
- Arntz-style symbols
- Proper ISOTYPE layout rules
- Maybe: toggle to show same data as bar chart, revealing the trade-offs

**Or**: Apply ISOTYPE style to modern data
- Population comparison (countries, cities)
- Energy consumption
- Something from PSD3's own stats (modules, lines of code, FFI calls)

### Scope

Tiny. This is:
- A symbol set (SVG paths)
- A layout function
- One showcase page

Fits the "psd3-music pattern" perfectly.

### Anagram Candidates

"ISOTYPE" = "Typoise"? "Peyotis"? (Short words are hard)

### Parking Lot

- Source high-res Arntz pictograms? (Many are public domain now)
- Neurath archive online?
- Modern ISOTYPE practitioners to reference? (There's been a revival)

### Relationship to Other Ideas

| Aspect | ISOTYPE | Other ideas |
|--------|---------|-------------|
| Historical | Yes (1920s-30s) | All modern |
| Visual style | Pictographic, flat | Varies |
| Data philosophy | Unit-based, discrete | Usually continuous |
| Effort | Low | Low-High |
| "Wow" | Understated, thoughtful | Varies |

This is the most *historically grounded* idea - it says "we know where this field came from."
