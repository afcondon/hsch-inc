# 2026-02-13

## Accomplished

### Analysis: haskell-obj-c and PureScript-over-Objective-C Feasibility

Investigated [iand675/haskell-obj-c](https://github.com/iand675/haskell-obj-c), a brand-new project (created Feb 11, 2026) providing type-safe Haskell bindings to Apple's Objective-C runtime, and assessed whether a similar approach could work for PureScript.

#### haskell-obj-c Summary

- **Runtime library** wrapping `libobjc`: message sending via libffi, ARC-compatible memory management via `ForeignPtr` + release finalizers, phantom-typed `Id a` pointers encoding the class hierarchy, ObjC block construction from Haskell closures, three mechanisms for creating ObjC classes backed by Haskell logic (vtable/TH, StablePtr, ActionTarget).
- **Code generator** that invokes Clang to dump macOS SDK headers as JSON AST, producing typed Haskell binding packages for 172 Apple frameworks (212 packages, 7,532 files). Handles class hierarchies, protocols-as-typeclasses, delegate records, enums, structs, and cross-framework category extensions with cycle-aware dependency resolution.
- Key technical choices: libffi for dynamic dispatch (not one `foreign import` per method), phantom types for class hierarchy, three ownership patterns (+1/+0/borrowed), ObjC protocols as Haskell typeclasses.
- Status: 9 commits, 36 stars, "not ready for production use," but has 7 working example apps, full test suite, `.app` bundler tool.

#### Two Different Questions

The haskell-obj-c project is an **FFI binding library**, not a compiler backend. "PureScript-over-Obj-C" could mean:

- **(A) FFI bindings**: Make PureScript call ObjC APIs through a native backend.
- **(B) Compiler backend**: Make PureScript compile to Objective-C source code.

#### Local Backend Reference Implementations

Reviewed three local backends in `purescript-backends/`:

| Backend | Architecture |
|---|---|
| **purerl** | Standalone exe, direct CoreFn -> Erlang translation |
| **purescript-python-new** | CoreFn -> Python AST -> pretty-printed Python (`CodeGen.hs` + `AST.hs` + `Pretty.hs`) |
| **purescript-lua** | CoreFn -> custom IR (with optimizer, inliner, DCE, linker) -> Lua AST -> Lua source |

The Lua backend is the most sophisticated, with its own intermediate IR layer between CoreFn and Lua -- essentially the same idea as Arista's `purescript-backend-optimizer` but self-contained.

#### Feasibility Assessment

A PureScript -> Objective-C backend is **architecturally feasible** but faces harder challenges than existing backends:

**Hard problems:**
1. **Memory management**: PureScript assumes GC; Obj-C uses ARC. Pervasive curried closures create retain cycle risk. Solutions: Boehm GC (like `pure-c`), reference counting with cycle detection, or hybrid (C runtime for PS values, Obj-C objects only at FFI boundary).
2. **Closure representation**: Obj-C blocks are heavyweight heap allocations. Better to use C structs (function pointer + environment), wrapping as Obj-C blocks only at FFI boundary.
3. **FFI rewrite**: Every core PureScript library needs Obj-C FFI files -- the biggest effort barrier.

**What makes it easier:**
- CoreFn is simple untyped lambda calculus (type classes already compiled to dictionary passing)
- Three working backend codebases to study locally
- purescript-lua's IR layer is a good model (optimizer/inliner/DCE reduces closure allocations)
- Objective-C is a strict superset of C, so a `pure-c`-style approach works as starting point

#### Recommended Phased Strategy

| Phase | Approach | Outcome |
|---|---|---|
| **1** | Generate C (like `pure-c`) that compiles as Obj-C with Boehm GC | PureScript logic runs natively on Apple platforms |
| **2** | Write Obj-C FFI files for Apple framework access (AppKit, UIKit, Foundation) | PureScript can call Apple APIs |
| **3** | Auto-generate typed bindings from framework headers (like haskell-obj-c's codegen) | Type-safe Apple API access from PureScript |

#### What Transfers from haskell-obj-c

- The libffi runtime approach **does not** directly transfer (requires GHC native compilation).
- The **code generator design** does transfer: parsing Clang AST JSON to produce typed framework bindings, class hierarchy encoding via phantom types, delegate/protocol patterns. These work regardless of which language calls into the Obj-C runtime.

## Explored But Not Pursued

- **pureswift** (paulyoung/pureswift): Stale, unmaintained Swift backend for PureScript. 64 stars, no releases. Not a viable starting point.
- **PureScript JS in JavaScriptCore**: Running PS's JS output in `JSContext`/`WKWebView` on Apple platforms. Works today but isn't truly native.
- **purescript-native (C++)**: Existing C++ backend by Andy Arvanitis. Generates C++11, compatible with Objective-C++ (`.mm` files). Could be a bridge path but the project targets PureScript 0.14.x.

## Parking Lot

- Could the purescript-lua IR layer be extracted as a reusable optimization pass for other backends?
- The haskell-obj-c codegen's cycle-aware dependency resolution for cross-framework categories is an interesting pattern -- might be useful for PureScript framework binding generation regardless of backend choice.
- Arista's `purescript-backend-optimizer` as an alternative foundation to purescript-lua's IR for a new backend.

## Decisions Made

- None yet -- this was exploratory research.

## Next Session Setup

- If pursuing this further, start by reading `purescript-backends/purescript-lua/lib/Language/PureScript/Backend/IR/Types.hs` to understand the Lua backend's IR design, as it's the best local model for a new backend with optimization.
- Review `pure-c` (github.com/pure-c/purec) for the C-with-Boehm-GC approach that would be Phase 1.
- The haskell-obj-c codegen source (`codegen/`) would be relevant for Phase 3 framework binding generation.
