# Worklog: 2026-01-27

## Session Focus
Complete HATS tick-driven transition implementation for TourMotionScrollyHATS, replacing Web Animations API with PSD3's native tick engine.

## Accomplished

### Tick-Driven HATS Transitions (Complete)

- **Moved transition primitives to psd3-selection**: Copied Tick.purs, Easing.purs, Interpolate.purs, Engine.purs from psd3-simulation to psd3-selection. Removed duplicates from simulation. Selection is the lower-level library; simulation imports from it.

- **Created `PSD3.HATS.Transitions` module**: Tick-driven transition state management for HATS GUP animations.
  - `HATSTransitions` type with entering/updating/exiting element transitions
  - `tickTransitions :: Number -> HATSTransitions -> Effect TransitionResult`
  - `TransitionResult = Running HATSTransitions | Complete`
  - `toTickEasing` conversion from HATS easing to Tick easing functions

- **Created `PSD3.HATS.InterpreterTick` module**: New tick-driven interpreter that returns transitions instead of using Web Animations API.
  - `rerender :: String -> Tree a -> Effect RerenderResult`
  - Returns `{ selections, transitions :: Maybe HATSTransitions }`
  - Creates transitions for ENTER/UPDATE/EXIT numeric attributes
  - Applies non-numeric attrs immediately (colors can't interpolate)

- **Updated TourMotionScrollyHATS component**:
  - Added `transitions :: Maybe T.HATSTransitions` to state
  - Added `transitionFiber :: Maybe H.ForkId` for tick loop
  - Added `TransitionTick Number` action
  - Created `rerenderWithTick` helper that starts ~60fps tick loop when transitions returned
  - All 6 HATS-based steps now use tick-driven transitions

### Bug Fixes During Implementation

- **Fixed UPDATE flash**: Removed immediate application of template attrs for UPDATE elements - the tick loop interpolates from current DOM values to target.

- **Fixed always-green GUP elements**: Added `applyNonNumericAttrs` helper that applies string attributes (like fill colors) immediately since they can't be interpolated. Now ENTER=green, UPDATE=gray, EXIT=brown as intended.

## Architecture Notes

The tick-driven approach matches PSD3's "open tick architecture":
1. Data changes trigger `rerenderWithTick`
2. HATS interpreter creates/updates DOM, returns transition specs
3. Component forks a tick loop (~16ms intervals)
4. Each tick calls `T.tickTransitions deltaMs` which interpolates and applies values
5. When `Complete`, loop stops

This integrates cleanly with force simulations - both consume ticks from the same source.

## Explored But Not Pursued

- **Web Animations API**: Initially the HATS interpreter used Web Animations API but this conflicted with the open tick architecture. Removed in favor of tick-driven approach.

## Parking Lot

- **Step 8 (Tree/Cluster animation)**: Already has its own tick-driven system in AnimatedTreeCluster.purs. Deferred to after static layout examples are converted.

- **Step 9 (Les Mis force graph)**: Uses existing force simulation, not HATS. May or may not need conversion.

- **psd3-transitions library**: The transition primitives could be extracted to a separate library mirroring D3's d3-ease/d3-interpolate/d3-transition structure. Added note in Transitions.purs header.

## Decisions Made

- **Tick-driven over Web Animations**: Maintains integration with force simulations and other tick sources.

- **Transitions in psd3-selection**: More accessible than psd3-simulation. Can be split out later if needed.

- **Non-numeric attrs apply immediately**: Colors and text can't interpolate, so they change at phase boundaries rather than animating.

---

## Session 2: Fold Scoping Bug Fix

### Critical Bug Fixed: Sibling Folds Interfering

Discovered and fixed a fundamental bug in the HATS Fold interpreter: when two sibling Folds existed in the same parent, each Fold's GUP would affect all children of the parent, not just its own elements. This caused the second Fold to remove the first Fold's elements as "exiting".

**Root cause**: `getChildElements p` in the Fold case got ALL children, not filtered by element type.

**The Fix**: Added `elementType :: ElementType` to the Fold spec, mirroring D3's `selectAll("path")` pattern:

1. **Updated HATS types** (`PSD3.HATS`):
   - Added `elementType :: ElementType` to Fold record
   - Updated `forEach`, `forEachWithGUP`, `fromTree`, `preserveTree` combinators to accept element type parameter

2. **Updated both interpreters** (`Interpreter.purs`, `InterpreterTick.purs`):
   - Added `getChildElementsByTagName` FFI function
   - Added `elementTypeToTagName :: ElementType -> String` helper
   - Changed Fold case from `getChildElements p` to `getChildElementsByTagName p tagName`

3. **Updated all call sites** (~30 files):
   - All `forEach` calls now include element type: `forEach "circles" Circle data keyFn template`
   - All `forEachWithGUP` calls updated similarly
   - For heterogeneous templates (chimera pattern), wrap in Group

**API change example**:
```purescript
-- Before:
forEach "circles" data keyFn \d -> elem Circle [...]

-- After:
forEach "circles" Circle data keyFn \d -> elem Circle [...]
```

### TreeVizHATS Two-Pass Rendering

TreeVizHATS demonstrates the pattern for mixed datum types (links use `LinkDatum`, nodes use `HierNode`):

```purescript
-- First pass: create named containers
result1 <- HATS.rerender selector structureViz

-- Second pass: render links into linksGroup
_ <- HATS.rerenderInto result1.selections "linksGroup" (linksTree padding links)

-- Third pass: render nodes into nodesGroup
_ <- HATS.rerenderInto result1.selections "nodesGroup" (nodesTree padding nodes)
```

Added `rerenderInto :: SelectionMap -> String -> Tree a -> Effect RerenderResult` to InterpreterTick.

## Next Steps (Same Session)

Continue converting remaining TourHierarchies layouts:
1. ~~TreeViz~~ ✓ (vertical tidy tree) - completed with two-pass pattern
2. HorizontalTreeViz
3. RadialTreeViz
4. ClusterViz
5. PartitionViz
6. SunburstViz
7. TreemapViz
8. PackViz
9. EdgeBundleViz

All must convert to validate the HATS AST before merging feature branch.

---

## Session 3: Existential Fold for Heterogeneous Tree Composition

### Problem Statement

The original HATS `Tree a` type was parameterized by datum type, which prevented heterogeneous composition. In visualizations where links use `LinkData` and nodes use `HierNode`, you couldn't write:

```purescript
-- This didn't work: different datum types
linksLayer :: Tree LinkData
nodesLayer :: Tree HierNode
combined = linksLayer <> nodesLayer  -- Type error!
```

This forced awkward workarounds: sum types, multiple render passes, or losing type safety.

### Solution: Existentially-Scoped Data Binding

Implemented a fundamental redesign where `Tree` has **no type parameter** and each `Fold` packs its own datum type existentially using CPS encoding.

**Key insight**: The datum type `a` is only needed inside the template function. By capturing datum values in closures at template instantiation time, the type can be "erased" from the outer Tree type.

### Implementation Details

**1. CPS-Encoded Existential (`HATS.purs`)**
```purescript
-- No type parameter - trees compose freely
data Tree
  = Elem { elemType, attrs, children, behaviors }
  | MkFold SomeFold
  | Empty

-- CPS encoding since PureScript lacks native existentials
newtype SomeFold = SomeFold (forall r. (forall a. FoldSpec a -> r) -> r)

mkSomeFold :: forall a. FoldSpec a -> SomeFold
mkSomeFold spec = SomeFold (\k -> k spec)

runSomeFold :: forall r. SomeFold -> (forall a. FoldSpec a -> r) -> r
runSomeFold (SomeFold f) k = f k
```

**2. Thunked Attributes and Behaviors**
```purescript
-- Attributes: either static or thunked (closure captures value)
data Attr
  = StaticAttr String String
  | ThunkedAttr String (Unit -> String)

-- Behaviors: closures capture datum at template time
data ThunkedBehavior
  = ThunkedMouseEnter (Unit -> Effect Unit)
  | ThunkedMouseLeave (Unit -> Effect Unit)
  | ThunkedClick (Unit -> Effect Unit)
  | ThunkedDrag DragConfig
  | ThunkedZoom ZoomConfig
```

**3. User-Facing API Unchanged**
```purescript
-- User writes this - 'a' is inferred and scoped to template
forEach :: forall a. String -> ElementType -> Array a -> (a -> String) -> (a -> Tree) -> Tree

-- Inside template, datum captured in closures:
forEach "nodes" Circle nodes _.path \node ->
  withBehaviors [ onMouseEnter (callbacks.onHover node.path) ] $
  elem Circle [ F.cx node.x, F.cy node.y ] []
```

**4. Interpreter Pattern**
```purescript
-- Process Folds with polymorphic continuation
case tree of
  MkFold someFold -> runSomeFold someFold \spec -> do
    -- All processing must happen inside this continuation
    -- to prevent skolem escape
    let items = runEnumeration spec.enumerate
    ...
```

### New Files Created

- `PSD3/HATS/Friendly.purs` - Convenience helpers for new `Attr` type (`F.viewBox`, `F.cx`, `F.fill`, etc.)

### Files Modified

- `PSD3/HATS.purs` - Complete rewrite with existential design
- `PSD3/HATS/InterpreterTick.purs` - Updated to use `runSomeFold`
- `Gallery/RenderHATS.purs` - Updated to new API, now uses `F.` helpers

### Files Temporarily Disabled

- `PSD3/HATS/Interpreter.purs` → `.legacy` (uses old parameterized types)
- `test/Test/HATSDemo.purs` → `.legacy` (uses old API)

### Validation

Gallery showcase (allergy-outlay) builds and bundles successfully with the new design. All 14 layout visualizations use the existential Fold pattern.

### Decisions Made

- **CPS over GADTs**: PureScript doesn't have native existential types; CPS encoding provides the same capability
- **Thunked over parameterized**: Attributes/behaviors capture values in closures rather than carrying type parameter
- **Friendly helpers**: Created `F.` module to avoid breaking change to existing attribute DSL

### See Also

- `docs/kb/architecture/hats-existential-design.md` - Full technical documentation

## Next Session Setup

Continue converting scrolly pages and remaining layouts to HATS:
- TourHierarchies layouts (9 remaining)
- TourMotionScrolly (already using HATS tick transitions)
- Other scrolly pages

The heterogeneous composition now enabled means links and nodes can be combined with `<>` in a single tree, simplifying the two-pass rendering pattern.

---

## Session 4: HATS Migration Continues + Coordinated Highlighting

### Accomplished

**Layout Gallery (allergy-outlay) - Coordinated Highlighting**

Converted all 14 layout renderers to use `onCoordinatedHighlight` instead of manual `Maybe String` hover state:

- Tree layouts (horizontal, vertical, radial)
- Cluster layouts (horizontal, vertical, radial)
- Pack, Sunburst, Icicle, Treemap
- Sankey, Chord, Edge Bundle, Adjacency

Key simplifications:
- Removed `HoverCallbacks` type and hover state from ComponentHATS
- Render functions now take only `selector` + `data` (no callbacks)
- Highlighting is automatic via HATS behaviors

Added CSS for flow layout highlighting (`.sankey-node`, `.chord-arc`, `.chord-ribbon`, `.bundle-node`, `.adjacency-cell`, etc.)

**FPFTW AnscombeQuartet - Converted to HATS**

Converted `Viz/FPFTW/AnscombeQuartet.purs` from old AST to HATS:
- Replaced `PSD3.AST`, `T.named`, `T.withChildren`, `renderTree` with HATS equivalents
- Added coordinated highlighting across all 4 datasets:
  - **Primary**: The hovered point
  - **Related**: Other points in same dataset
  - **Dimmed**: Points in other datasets
- Demonstrates FP pattern: `map scatterplot anscombeData` - one component, four instances

**TreeAPI Anscombe files**: Already using HATS (Single, Quartet, Overlay) - no conversion needed.

### Explored But Not Pursued

**Morphisms Zoo (psd3-prim-zoo-mosh)**: Analyzed for HATS conversion but determined it's an educational storybook with static SVG diagrams (no data binding). The DAG at the top could be a force layout, but simulation support isn't ready yet.

### Parking Lot

**HATS for Music Composition**

A potentially compelling future direction: applying the hylomorphic pattern to music/audio composition.

**Enumeration (coalgebra - unfold)**:
- `FromTree` → hierarchical phrase structure (song → section → phrase → measure → beat)
- `FromArray` → sequential events (melody, chord progression)
- `WithContext` → events with position/depth (voice leading, counterpoint)

**Assembly (algebra - fold)**:
- `Siblings` → parallel voices, polyphony
- `Nested` → hierarchical time (measures containing beats containing subdivisions)

**Data join for music**:
- Enter → note onset, attack
- Update → sustain, modulation, pitch bend
- Exit → release, decay, fade out

**Multiple interpreters from one spec**:
- Web Audio → actual sound
- MIDI → hardware synths, DAWs
- Notation → sheet music (Lilypond, MusicXML)
- Tidal/Strudel → live coding patterns
- English → "a C major arpeggio ascending over 2 bars"

The key insight: describe a piece as a *tree transformation* - take input data (anything: stock prices, weather, Anscombe's quartet), unfold into musical structure, fold into sound. Same composition logic + different data = different pieces. Different interpreters = different outputs.

Tidal's mini-notation is powerful but imperative. A HATS-style approach would be declarative and compositional - `melody <> bassline <> drums` with free composition regardless of internal datum types.

Worth exploring once HATS foundation is solid.

### Files Modified

- `allergy-outlay/src/Gallery/RenderHATS.purs` - Full coordinated highlighting
- `allergy-outlay/src/Gallery/ComponentHATS.purs` - Simplified, removed hover state
- `allergy-outlay/src/Gallery/Style.css` - Added flow layout highlight CSS
- `site/website/src/Viz/FPFTW/AnscombeQuartet.purs` - Converted from old AST to HATS
