# Worklog: 2026-01-28

## Accomplished

### HATS Migration Complete for TourMotionScrolly

The `/tour/scrolly2` page is now fully HATS-based with tick-driven transitions, covering all major visualization use cases:

1. **Single element animations** (steps 1-2) - opacity fading, position movement
2. **Multi-element synchronized animations** (step 3) - lockstep movement
3. **Staggered animations** (step 4) - wave effect with per-element delay
4. **GUP circles** (step 5) - enter/update/exit with color coding (green→gray→brown)
5. **GUP letters** (step 6) - text elements with bounce-in/drop-out transitions
6. **Tree ↔ Dendrogram** (step 8) - layout algorithm transitions
7. **Force-directed graph** (step 9) - LesMis with simulation + drag + zoom

### Bug Fixes

1. **Exit transitions not animating**: Fixed order of operations in `InterpreterTick.purs` - was applying exit attrs BEFORE reading current values for transitions. Now creates transitions first (capturing current "from" values), then applies only non-numeric attrs.

2. **Container not clearing between steps**: `clearViz` was using `rerender` with empty tree, but interpreter reuses existing elements. Changed to use `clearContainer` which actually removes DOM children.

### Route Changes

- `/tour/scrolly2` → Now serves HATS tick-driven version (was Web Animations API)
- `/tour/scrolly2-legacy` → Old Web Animations API version (for comparison)

### Documentation

Created `docs/modules/ROOT/pages/how-to/clearing-containers.adoc` explaining:
- When to use GUP (within a fold, for data changes)
- When to use `clearContainer` (between different tree structures)
- Common mistake of using `rerender` with empty tree

## Decisions Made

1. **Unified tick architecture confirmed**: The tick-driven transition system successfully handles both:
   - GUP transitions (enter/update/exit)
   - Force simulation animations
   - Layout algorithm transitions

   No D3 transitions or Web Animations API needed.

2. **clearContainer vs GUP**: These serve different purposes and both are needed:
   - GUP: manages element lifecycle within a fold (keyed diffing)
   - clearContainer: clears DOM when tree structure changes completely

## Files Modified

**Library (psd3-selection):**
- `src/PSD3/HATS/InterpreterTick.purs` - Fixed exit transition ordering
- `docs/modules/ROOT/pages/how-to/clearing-containers.adoc` - New documentation

**Website:**
- `src/Component/Tour/TourMotionAnimationsHATS.purs` - Use `clearContainer` for clearViz
- `src/Component/Tour/TourMotionScrollyHATS.purs` - Clear container on step change
- `src/RoutingDSL.purs` - Swap scrolly2 routes (HATS is now default)

---

## Session 2: Library Extraction

### Extracted psd3-transitions Library

Moved pure transition primitives from psd3-selection to new `psd3-transitions` library, mirroring D3's structure (d3-ease, d3-interpolate, d3-transition).

**New library contains:**
- `Tick.purs` - Progress type, lerp, easing functions
- `Easing.purs` - EasingType enum with all D3 easings
- `Interpolate.purs` - Point, RGB, HSL interpolation
- `Engine.purs` - TransitionSpec, TransitionState, tick-driven state machine
- `Coordinator.purs` - RAF loop management
- `RAF.purs` + `RAF.js` - requestAnimationFrame FFI

**Dependency structure:**
```
psd3-transitions (new, pure)
       ↑
psd3-selection (depends on transitions)
       ↑
psd3-simulation, website, etc.
```

**What stays in psd3-selection:**
- `PSD3/Internal/Transition/` - DOM/selection integration (Types, Manager, Scene, FFI)
- `PSD3/HATS/Transitions.purs` - HATS-specific transition orchestration

### Files Created
- `visualisation libraries/purescript-psd3-transitions/` - New library
- `visualisation libraries/purescript-psd3-transitions/spago.yaml`
- `visualisation libraries/purescript-psd3-transitions/src/PSD3/Transition/*.purs`

### Files Modified
- `visualisation libraries/purescript-psd3-selection/spago.yaml` - Added psd3-transitions dependency
- `site/website/spago.yaml` - Added psd3-transitions to extraPackages
- Removed `visualisation libraries/purescript-psd3-selection/src/PSD3/Transition/`

---

## Session 3: Brush Coordination for HATS

### Context

Investigated converting the penguins SPLOM (`/splom`) to HATS to test edge cases. Found that:
- The existing SPLOM uses old Tree API (`T.named`, `T.elem`, `renderTree`)
- It has brush interaction that was implemented imperatively (post-render attachment)
- The existing `PSD3.Interaction.Coordinated` module already has infrastructure for brush + hover coordination

### Added Brush Support to HATS

Extended HATS to support coordinated interaction (brush + hover) with two new behavior types:

**1. `ThunkedCoordinatedInteraction`** - Full interaction response
```purescript
onCoordinatedInteraction
  { identify: pt.id
  , respond: \trigger -> case trigger of
      HoverTrigger id -> if pt.id == id then Primary else Dimmed
      BrushTrigger box -> if pointInBox pt.pos box then Selected else Dimmed
      ClearTrigger -> Neutral
      _ -> Neutral
  , position: Just pt.pos
  , group: Just "scatter-plot"
  }
```

**2. `ThunkedBrush`** - Attaches brush overlay to element
```purescript
onBrush
  { extent: { x0: 0.0, y0: 0.0, x1: 400.0, y1: 300.0 }
  , group: Just "scatter-plot"
  }
```

### How It Works

1. Elements register with `onCoordinatedInteraction` specifying how they respond to any trigger
2. A brush overlay attached with `onBrush` emits `BrushTrigger` on drag
3. All registered elements receive the trigger and get CSS classes:
   - `coord-primary` - direct target
   - `coord-related` - related elements
   - `coord-selected` - inside brush region
   - `coord-dimmed` - unrelated

This pattern mirrors hover highlighting but extends to brush selection.

### Files Modified

**`src/PSD3/HATS.purs`:**
- Added `ThunkedCoordinatedInteraction` behavior type
- Added `ThunkedBrush` behavior type
- Added `onCoordinatedInteraction` smart constructor
- Added `onBrush` smart constructor
- Import `InteractionTrigger`, `InteractionState`, `BoundingBox` from Coordinated

**`src/PSD3/HATS/InterpreterTick.purs`:**
- Added `interactionStateToInt` conversion function
- Added handler cases for new behavior types
- Added FFI declarations for `attachCoordinatedInteractionThunked` and `attachCoordinatedBrushThunked`

**`src/PSD3/HATS/InterpreterTick.js`:**
- Added `coordInteractionRegistry` for tracking elements
- Added `applyCoordInteraction` function
- Added `attachCoordinatedInteractionThunked` FFI
- Added `attachCoordinatedBrushThunked` FFI (implements native brush with pointer events)

### Architecture Notes

- Uses native pointer events for brush (no D3 brush dependency)
- Separate registry from HATS hover highlighting (which uses `hatsHighlightRegistry`)
- CSS classes: `coord-primary`, `coord-selected`, `coord-dimmed` (different from `highlight-*` classes)
- The Coordinated module exports `InteractionTrigger(..)`, `InteractionState(..)`, and `BoundingBox` for custom respond functions

### Next Steps

1. **Create HATS SPLOM**: Convert the penguins SPLOM to use the new HATS brush infrastructure
2. **Test performance**: Verify that brush updates at interactive speeds (~60fps) with ~3600 circles
3. **Document the pattern**: Add how-to for HATS brush coordination

## Next Session Setup

Ready to convert SPLOM to HATS with brush support:
- Infrastructure is complete in psd3-selection
- Website builds successfully
- Need to create `Viz/SPLOM/SPLOMHATS.purs` using new brush behaviors

---

## Session 4: beads-purs - PureScript Issue Tracker

### Context

Discovered Steve Yegge's [beads](https://github.com/steveyegge/beads) - a git-backed issue tracker for AI coding agents. Rather than install the "100% vibe coded" Go version, decided to port to PureScript as a learning exercise and to get a typed, trustworthy implementation.

### Accomplished

**Complete working CLI** at https://github.com/afcondon/beads-purs

Built from scratch in one session:

1. **Core architecture** (PureScript-first, not a direct port):
   - `Store` - immutable `Map IssueId Issue`
   - `Commands` - pure `Store → Either Error Store` transformations
   - `Queries` - pure `Store → Array Issue` queries
   - `App` - effectful wrapper (load/save/git)
   - `Main` - CLI argument parsing

2. **Full command set**:
   - `bd init` - initialize repo
   - `bd create "title" -p N` - create issue
   - `bd ready` - show unblocked issues by priority
   - `bd list -s query` - list/search open issues
   - `bd show <id>` - full issue details
   - `bd close <id> "reason"` - close issue
   - `bd dep add/rm <a> <b>` - manage dependencies
   - `bd edit <id> -t/-p` - modify title/priority
   - `bd stats` - statistics

3. **Key features**:
   - Auto git-commit on every write
   - Dependency blocking (`bd ready` only shows unblocked)
   - JSONL format compatible with original beads
   - Graceful error when not in a beads repo

4. **Dogfooding**: Used beads-purs to track beads-purs development. All 5 implementation issues created, tracked with dependencies, and closed.

5. **Published**: Public repo with README, cheatsheet, CLAUDE.md snippet for AI usage.

### Key Design Decision

**PureScript-first vs direct port**: The Go version has SQLite cache, daemon, and "molecules/wisps" for incremental state. We skipped all of that:

- No SQLite cache needed (Map *is* the cache, rebuilt on load - 836 issues in <1s)
- No daemon (load fresh each command)
- No molecules/wisps (that's solving mutable state in Go; in PureScript it's just function composition)

Result: ~600 lines of PureScript vs ~306K lines of Go, with the core functionality working.

### Files Created

```
/Users/afc/work/afc-work/purescript/beads-purs/
├── src/
│   ├── Main.purs (164 lines) - CLI
│   ├── Main.js - parseInt FFI
│   └── Beads/
│       ├── App.purs (170 lines) - effectful operations
│       ├── App.js - isInfixOf FFI
│       ├── Core/
│       │   ├── Types.purs - Issue, Status, Priority, etc.
│       │   ├── Store.purs - immutable Map wrapper
│       │   ├── Commands.purs - pure transformations
│       │   ├── Queries.purs - pure queries
│       │   ├── Issue.purs - JSON codecs
│       │   └── Id.purs - ID generation
│       └── Storage/
│           ├── JSONL.purs - parse/serialize
│           └── FileSystem.purs - file operations
├── bin/
│   ├── bd - executable wrapper
│   └── bd.js - bundled app (242KB)
├── CHEATSHEET.md - printable quick reference
└── README.md - full documentation
```

### Explored But Not Pursued

1. **SQLite cache**: The Go version uses SQLite for fast queries. We found Map-based queries fast enough for ~1000 issues. Can add later if needed.

2. **Daemon mode**: Go version has a daemon for file watching and auto-sync. We do load-on-demand which is simpler and sufficient for CLI use.

3. **Molecules/wisps**: Go's incremental state tracking system. In PureScript, pure `Store → Store` functions obviate this entirely.

4. **MCP server**: Could expose beads as Claude tools. Added CLAUDE.md snippet instead - simpler, works now.

### Parking Lot

- Could add `bd reopen` command
- Could add labels support (`bd label add/rm`)
- Could add comments support
- Could add time estimates
- Browser UI with Halogen?
- MCP server for tighter Claude integration?

### Decisions Made

1. **Hash-based IDs**: Keep beads' `bd-XXXX` format - prevents merge conflicts across machines
2. **JSONL format**: Stay compatible with original beads for potential interop
3. **Auto-commit**: Every write commits to git - this is the killer feature for AI agents
4. **No FFI for ADTs**: User caught me assuming PureScript runtime representation in FFI. Used pure PureScript `sortBy` instead.

### Reports Generated

- README.md with full documentation
- CHEATSHEET.md for quick reference (printable)
- CLAUDE.md snippet for AI agent usage

### Next Session Setup

beads-purs is feature-complete for basic use. Potential next steps:
- Try it on a real project (PSD3?)
- Add more features if friction is discovered
- Consider MCP server for Claude tool integration

---

## Session 5: Hylograph Guide + HATS Project Type Class

### Accomplished

**Hylograph Guide Showcase** - Interactive demonstration of HATS with polished examples:

1. **Grouped Bar Chart** - US population by state/age, demonstrates nested Fold
2. **Board Games** - Chess, Sudoku, Scrabble boards
   - Scrabble fully chrome'd: green border, "SCRABBLE" text, bonus squares, center star, styled tiles with point values
3. **Map Diagrams** - `Data.Map` as classic function diagrams (domain→codomain with arrows)

**Critical Bug Fix**: Interpreter sibling positioning bug - siblings after `forEach` were merged into the last forEach element. Fixed by tracking cumulative DOM position instead of logical child index.

**Finally Tagless `Project` Type Class** - Added to `PSD3/HATS.purs`:

```purescript
class Project source target | source -> target where
  project :: source -> Array target

newtype MapKeys k v = MapKeys (Map k v)
newtype MapValues k v = MapValues (Map k v)
newtype MapEntries k v = MapEntries (Map k v)

forEachP :: forall s t. Project s t => String -> ElementType -> s -> (t -> String) -> (t -> Tree) -> Tree
```

**The story**: One Map, three projections, one diagram. The MapDiagram now uses:
- `forEachP "keys" (MapKeys m)` → domain nodes
- `forEachP "values" (MapValues m)` → codomain nodes (auto-deduplicated)
- `forEachP "arrows" (MapEntries m)` → arrows connecting them

### Files Created

- `showcases/hylograph-guide/` - New showcase
- `src/Examples/GroupedBarChart.purs`
- `src/Examples/BoardGames.purs`
- `src/Examples/MapDiagram.purs`
- `src/AxisHATS.purs`
- `docs/kb/plans/hats-projection-typeclass.md`

### Files Modified

- `visualisation libraries/purescript-psd3-selection/src/PSD3/HATS.purs` - Added Project type class, Map projections, forEachP
- `visualisation libraries/purescript-psd3-selection/src/PSD3/HATS/InterpreterTick.purs` - Fixed sibling positioning bug

### Parking Lot

**LLM Elaboration Session**: Since LLMs excel at elaboration, dedicate a future session to having Claude add a large number of useful "off the shelf" components to libraries (like layouts). People love ready-made utilities. The Map projections are a good example - could do similar for Set, Tree (Nodes/Leaves/Edges), Graph, and domain-specific data structures.

- Railroad diagrams for parser visualization (pending)
- Move MapDiagram to a library for reuse

### Decisions Made

1. **Finally tagless for extensibility**: The `Project` type class is open - users can add their own projections without modifying HATS
2. **Functional dependency `source -> target`**: Each source type has one canonical projection; use newtypes for multiple views

### Next Session Setup

- Railroad diagram example still pending
- Consider the "LLM elaboration" session for bulk-adding useful utilities

---

## Session 6: Railroad Diagrams + App Shell Design

### Accomplished

**Railroad Diagram Example** - Complete grammar visualization:

Created `RailroadDiagram.purs` with:
- Grammar AST: `Terminal`, `NonTerminal`, `Sequence`, `Choice`, `Optional`, `Repeat`, `RepeatOne`
- Layout computation (widths, heights, rail positions)
- SVG rendering with proper curves for branches, bypasses, and loops
- Styling: green rounded rects for terminals, purple rects for non-terminals
- Two sample grammars: JSON Value (shows Choice), Arithmetic Expression (shows Sequence + Repeat)

**App Shell Design** - Halogen structure for the unified guide:

Created `App.purs` with 5 sections following `hylograph-guide-unified.md`:
1. **Intro** - Hook + simple demo
2. **Matrix** - Enum×Assembly dropdowns + AST diagram + output
3. **Examples** - Tabbed: Maps, Parsers (Railroad), Free Monads
4. **Interpreters** - Same HATS tree → multiple outputs
5. **Playground** - Editor + viz type selector + live output

Created `app.css` with dark theme:
- Black background, gold accents (Ana/Cata aesthetic)
- Responsive grid layouts
- Tab styling for Examples sub-navigation

### Files Created

- `src/Examples/RailroadDiagram.purs` - Grammar AST + layout + HATS rendering
- `src/Examples/RailroadDiagram.js` - String length FFI
- `src/App.purs` - Halogen app shell
- `public/app.css` - Dark theme styling

### Files Modified

- `src/Main.purs` - Added Railroad diagram renders
- `public/index.html` - Added Railroad diagram section

### Parking Lot

**LLM Elaboration Session**: Dedicate a future session to bulk-adding useful "off the shelf" components to libraries. The Map projections and Railroad diagrams are good examples - could do similar for Set, Tree, Graph, and domain-specific structures.

**Railroad Refinements**:
- Optional bypass paths are cramped in nested structures
- Entry/exit rails could extend further
- Add arrow markers on loop-back paths

### Current State

Hylograph Guide now has 4 polished examples:
1. Grouped Bar Chart (nested Fold)
2. Board Games (enum×assembly matrix demo)
3. Map Diagrams (Project type class, three projections)
4. Railroad Diagrams (recursive grammar → visual paths)

App shell is scaffolded but not yet wired to render visualizations. Next step is integrating the existing demos into the Halogen app structure.

### Next Session Setup

- Refine Railroad diagram curves/spacing
- Wire App.purs to render visualizations in section slots
- Build Matrix section AST diagram component
- Consider Free Monad flowchart example

---

## Session 7: MetaHATS Interpreter

### Accomplished

**MetaHATS Interpreter** - A true `Tree → Tree` interpreter that visualizes HATS tree structure:

```purescript
interpretMeta :: MetaConfig -> Tree -> Tree
```

Walks the actual HATS AST:
- `Elem` nodes → blue boxes showing element type (SVG, G, Rect, etc.)
- `MkFold` nodes → gold-bordered compound glyphs with enum×assembly icons
- Horizontal tree layout with elbow connectors

Key insight: Uses `runSomeFold` to extract FoldSpec from existentially-wrapped folds, accessing name, enumerate, and assemble to render the compound glyph.

**Fold Compound Glyph Design**:
```
┌─────────────────────────┐
│  Fold "bars"            │
│  ≡  →  |||              │
│  Array   Siblings       │
└─────────────────────────┘
```

Icon vocabulary:
- Enumeration: `≡` (Array), `△` (Tree), `K/V/⟼` (Map projections), `#` (Context)
- Assembly: `|||` (Siblings), `⊏⊐` (Nested)

### Files Created/Modified

- `src/Examples/MetaHATS.purs` - Interpreter (pivoted from example approach)
- `src/Examples/MetaHATS.js` - unsafeIndex FFI
- `src/Main.purs` - Feed actual trees through interpreter
- `public/index.html` - Section 5 for MetaHATS visualizations

### Design Decision

**Interpreter vs Example**: User correctly identified that creating a separate `MetaTree` type was an example, not an interpreter. Pivoted to true `Tree → Tree` interpreter that works on any HATS tree automatically.

### Parking Lot

**Nested boxes layout**: Good for certain tree types, especially "chimera" form where successive single-child generations collapse. Add to someday list.

### Next

- Visual collapse for Fold repetition (deck of cards metaphor)
- Show template structure with stacked/offset copies suggesting "many of these"
