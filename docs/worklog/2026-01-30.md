
---

## Evening Session: Zoo Review & Sugiyama Planning

### Zoo Rewrite Status

**What works well:**
- DAG navigator now uses Sugiyama layout from hylograph-graph library
- Added `orientation` (Horizontal/Vertical) and `reversed` support to library
- Cata, Ana, Hylo diagrams render correctly from data model

**What's broken:**
- Apo diagram is pedagogically wrong - my data model can't express the key insight
- The original hand-drawn diagrams have rich visual storytelling:
  - Nodes with labels ("reuse!")
  - Chunked sublists `[7,9]` as visual units
  - Annotation text on connections ("2 < 5? Keep going...")
  - Insertion points / empty slots

**Decision needed:**
1. Revert complex schemes (apo, para, futu) to hand-coded
2. Enrich DiagramTypes.purs with labels, chunks, annotations
3. Full revert to original Component.purs

**Key insight verified:** The sorted list insertion example for apo is THE canonical example from the literature (Tim Williams's slides, "Fantastic Morphisms" paper). The original Zoo diagram is correct - shows `[7,9]` being reused without reconstruction.

### Recursion Schemes References

For evening reading:
- [Tim Williams's recursion-schemes slides](https://github.com/willtim/recursion-schemes/blob/master/slides.lhs) - excellent, has apo insertElem
- [Fantastic Morphisms and Where to Find Them](https://yangzhixuan.github.io/pdf/fantastic-morphisms.pdf) - comprehensive survey
- [Sorting Slower with Style](https://jtobin.io/sorting-slower-with-style) - practical examples
- [awesome-recursion-schemes](https://github.com/passy/awesome-recursion-schemes) - curated list

### Files Modified Today

- `visualisation libraries/purescript-hylograph-graph/src/Data/Graph/Layout.purs` - added orientation/reversed
- `showcases/psd3-prim-zoo-mosh/src/Zoo/MorphismDAG.purs` - new, DAG data + HATS rendering
- `showcases/psd3-prim-zoo-mosh/src/Zoo/Layout.purs` - height/padding tweaks
- `showcases/psd3-prim-zoo-mosh/src/Zoo/Component.purs` - uses computed DAG positions


### Overnight Ideas (pick one for next session)

**1. Sugiyama with Dummy Nodes**
- Proper Graphviz-style edge routing
- Insert virtual nodes for edges spanning multiple layers
- Enables crossing minimization to work on all segments
- Would improve Zoo navigator and enable general DAG viz

**2. Tschichold Git Timeline**
- Git history as a DAG with modernist aesthetic
- Jan Tschichold's asymmetric typography / New Typography
- Red/black two-color, dynamic tension, not centered
- Concrete use case: visualize actual repo history
- Forces handling of real complexity (merges, branches)

**3. L-Systems with Apomorphism Infinite Scroll**
- L-systems generate fractal plant structures
- Apomorphism = unfold with early exit
- Maps to: render visible portion, paste rest on scroll
- Meta-connection: use the scheme we're teaching to build viz
- See `docs/kb/plans/` for existing L-systems plan

All three need proper DAG/tree layout. Git and L-systems both benefit from Sugiyama improvements.

---

## Late Night Session: Catana Paper & L-System Implementation

### Catana Paper Discovery

Found the "Folding over Neural Networks" paper (MPC 2022) by Minh Nguyen & Nicolas Wu:
- [GitHub: min-nguyen/catana](https://github.com/min-nguyen/catana)
- [arXiv: 2207.01090](https://arxiv.org/abs/2207.01090)
- [HTML version](https://ar5iv.labs.arxiv.org/html/2207.01090)

Key insight: Neural networks encoded as recursive types (Fix/Free with coproducts "à la carte"). Training is metamorphism - forward propagation is cata, back propagation is ana. Meta: a neural network (Claude) collaborating on a hylomorphism-based visualization system.

### Ideas Written Up

**1. Catana → HATS Diagram Derivation** (`docs/kb/research/catana-hats-diagram-derivation.md`)
- Derive diagrams automatically from Haskell/PureScript types
- A catamorphism over the network type produces a HATS tree
- Type IS the diagram specification - no manual construction
- Could reproduce Catana paper figures (Figures 2 & 4) using Hylograph

**2. Grid Snapping in Force Layouts** (`docs/kb/research/grid-snapping-force-layouts.md`)
- Post-snap: Run simulation → snap final positions
- Grid force: Custom D3 force pulling toward grid points
- Annealing snap: Increase grid strength as simulation cools (best approach)
- Related "value-add" enhancements: edge bundling, symmetry detection, etc.

### L-System Implementation (Working!)

Implemented L-system visualization in `psd3-prim-zoo-mosh/src/Zoo/LSystem/`:

| File | Purpose |
|------|---------|
| `Types.purs` | LSystem, TurtleState, Segment, Viewport types |
| `Grammar.purs` | 12 classic L-systems (Koch, Dragon, Sierpinski, Plants, Hilbert...) |
| `Schemes.purs` | Core hylomorphism: expand (ana) + interpret (cata), plus apomorphism variant |
| `Render.purs` | SVG generation with depth coloring and animation support |
| `Demo.purs` | Test module |

**Verified working:**
- Koch curve (4 iter): 256 segments
- Dragon curve (12 iter): 4096 segments
- Fractal plant (5 iter): 1488 segments, depth-colored SVG

The apomorphism for lazy/infinite generation is structurally complete but needs UI integration for scroll-triggered expansion.

### KB Index Updated

- Added 3 new research docs + 2 new plans to INDEX.md
- Added "Recursion Schemes" as major theme #8
- Updated statistics: 62 total documents

### Files Created/Modified

**New files:**
- `docs/kb/research/catana-hats-diagram-derivation.md`
- `docs/kb/research/grid-snapping-force-layouts.md`
- `showcases/psd3-prim-zoo-mosh/src/Zoo/LSystem/Types.purs`
- `showcases/psd3-prim-zoo-mosh/src/Zoo/LSystem/Grammar.purs`
- `showcases/psd3-prim-zoo-mosh/src/Zoo/LSystem/Schemes.purs` + `.js`
- `showcases/psd3-prim-zoo-mosh/src/Zoo/LSystem/Render.purs` + `.js`
- `showcases/psd3-prim-zoo-mosh/src/Zoo/LSystem/Demo.purs`

**Modified:**
- `docs/kb/INDEX.md` - added new documents

### Next Steps

1. **Wire L-system into Zoo UI** - Add as new chapter/tab in the Halogen component
2. **Scroll-triggered apomorphism** - Actually implement the lazy infinite scroll
3. **Catana type → HATS demo** - Port Catana types to PureScript, derive diagrams
4. **Grid snap force** - Implement for psd3-simulation

### Parking Lot

- Could the L-system grammar be derived from data? (git branch patterns, file structure, code metrics)
- Parametric drift: L-system parameters vary as you scroll (angle drift, stochastic rules)
- Connection between this and Sugiyama: both need layer/grid-aware layout

---

## Morning Session: Recursion Scheme Variants for HATS

### The Question

Are there other recursion schemes that make sense at the operational center of HATS? Or is hylomorphism THE scheme for data→visualization?

### Analysis

**Why hylo is the natural fit:**
Visualization IS fundamentally an unfold-then-fold:
- Ana: unfold data into visualization tree
- Cata: fold tree into DOM operations
- Fused = hylo (intermediate tree can be virtual)

**Schemes that could be specialized variants:**

| Scheme | Potential Name | Use Case |
|--------|---------------|----------|
| **Apomorphism** | AATS | Lazy/infinite viz - stop when viewport filled. *Already demonstrated with L-systems!* |
| **Zygomorphism** | ZATS | Two-pass layout (measure then place). This is exactly what Flexbox/Grid do internally. |
| **Paramorphism** | PATS | Context-aware rendering - algebra sees original substructure, not just folded result. Breadcrumbs, relative sizing. |
| **Histomorphism** | HistoATS | "Show your work" viz - algebra sees entire history. Animated construction, debugging traces. |
| **Futumorphism** | FATS | Predictive rendering - generate multiple levels at once for LOD systems. |
| **Metamorphism** | MATS | Reactive/bidirectional viz - what Catana uses for NN training (forward cata + backward ana). |

### The ZATS Idea (Shelved for Now)

Zygomorphism is particularly interesting for layout algorithms:
```
Pass 1 (measure): compute intrinsic sizes bottom-up
Pass 2 (layout): assign positions using Pass 1 results
```

This is a "fold parameterized by another fold" - exactly a zygomorphism. Could explicitly encode layout algorithms like Sugiyama with proper measure/place separation.

**Decision**: Shelved in interest of shipping. Worth returning to.

### L-Systems and HATS

Current L-system implementation bypasses HATS - goes straight to segments. To use HATS:
1. Make expanded string into a HATS tree (not just string)
2. Turtle interpretation becomes a HATS interpreter
3. Could then demonstrate AATS (apomorphic lazy generation of HATS trees)

**Decision**: Existing turtle code is compact and nice. Could add HATS layer for "successive elaboration" visualization but not essential for the demo.

### Key Insight

HATS is well-named. Hylomorphism IS the core operation for data→viz. The other schemes are **specialized variants** for specific needs (lazy generation, two-pass layout, context-awareness), not replacements.

### Next: Neural Network Layout

Moving on to add a new layout to the layout library specifically for neural network diagrams. This connects back to Catana - the diagrams in that paper show network architectures that need proper layered layout.

---

## Afternoon Session: Site Explorer & Typed Feedback Loops

### Site Explorer Complete

Built a full Site Explorer tool for analyzing Halogen routing codebases:

**Backend (ce-server):**
- `GET /api/site-explorer/routes/:snapshotId` - Routes with reachability status
- `GET /api/site-explorer/annotations` - List annotations
- `POST /api/site-explorer/annotations` - Create annotation (new!)
- `GET /api/site-explorer/report` - Classification report for LLM consumption

**Frontend (halogen-spider/site-explorer.html):**
- D3 force graph with clustering (unreachable routes pull left)
- Rose Adler Art Deco styling (inspired by Chéri binding, 1931)
  - Navy/burgundy/gold/cream palette
  - Cormorant Garamond + Raleway typography
  - Decorative gold corner accents
- Annotation controls: classification, action hints, notes
- Module names link to Code Explorer (with `?module=` query param for future integration)
- Real-time save to database with feedback

**Available at:** `http://localhost:8888/site-explorer.html`

### CSS Review Skill

Created `/css-review` skill after discussion about whether LLMs can write clean CSS. Key insight: quality is context/prompt dependent, not inherent limitation. Skill encodes what "clean CSS" means:
- Structure analysis (custom properties → base → components → utilities)
- Specificity health checks
- Modern CSS opportunities (grid, clamp, container queries)
- Naming convention consistency
- Performance considerations

Sent to ATP podcast (John Siracusa) as counterpoint to his skepticism.

### Typed Feedback Loops: Theoretical Framework

Extended shaped-steer vision doc with theoretical grounding from today's discussion:

**Core principle:** Typed multi-modal systems expose the same semantic structure through multiple representations, each with different comprehension/action affordances, connected by lossless round-tripping.

**Key insight:** Both comprehension AND actionability are representation-sensitive and task-dependent. Not "text=read, graphics=write" but "each representation has profiles for both, depending on what you're doing."

**Exemplars discussed:**
- Tidal Cycles (pattern → text → sound, with tilted-radio adding graphics)
- Spreadsheets (grid IS text+graphics fused, formula bar = instant round-trip)
- Build systems (Makefile text ↔ DAG visualization)

**Sankey as MetaHATS:** The right abstraction for data flow - nodes are typed blocks (tables, queries, files), not individual cells. Shows architecture invisible in the grid.

**Wider horizon:** Proof assistants, logic programming, SMT solvers all fit the paradigm - they're all "exploring a constrained space through typed feedback." Curry-Howard extended: constraints = types = propositions = specifications.

Added to `apps/shaped-steer/docs/UNIFIED-DAG-VISION.md`.

### Travis the Spherical Cow

Project mascot introduced. Named after the classic physics joke AND a certain tech founder's "exploring the edges of quantum physics with ChatGPT" moment.

Purpose: Feynman's maxim that "the easiest person to fool is yourself." Reminder that LLMs are agreeable, humans seek coherence, and together they can spiral into elaborate untethered abstractions. The antidote is building concrete things that can say no.

### Files Created/Modified

**New:**
- `.claude/commands/css-review.md` - CSS review skill
- `showcases/halogen-spider/site-explorer.html` - Force graph UI (Rose Adler edition)

**Modified:**
- `showcases/corrode-expel/ce-server/src/API/SiteExplorer.purs` - Added createAnnotation
- `showcases/corrode-expel/ce-server/src/API/SiteExplorer.js` - JSON parsing FFI
- `showcases/corrode-expel/ce-server/src/Main.purs` - POST handling for annotations
- `apps/shaped-steer/docs/UNIFIED-DAG-VISION.md` - Typed feedback loops + wider horizon

### Decisions Made

1. **Site Explorer lives in halogen-spider for now** - Will commit when permanent location decided
2. **Module links use query params** - `?module=Name` pattern ready for Code Explorer integration
3. **Theoretical additions go in shaped-steer** - Not FOSS, allows freedom to explore before deciding product vs patrimonio

### Parking Lot

- Wire Code Explorer to read `?module=` query param and focus on that module
- Atomic demo: CSV + SQL → Sankey → edit SQL → see update
- Could Site Explorer annotations feed back into LLM-assisted refactoring workflow?
- L-system + typed feedback loops connection (parametric exploration of constrained space)

### Next Session

- Use Site Explorer to actually classify routes for demo site cleanup
- Consider where Site Explorer should permanently live (standalone showcase? part of corrode-expel?)
- Start on spreadsheet → Sankey prototype to validate the typed feedback loop theory

